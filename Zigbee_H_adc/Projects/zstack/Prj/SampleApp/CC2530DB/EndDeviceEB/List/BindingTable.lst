###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               31/Oct/2019  10:27:25
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Components\stack\nwk\BindingTable.c
#    Command line       =  
#        -f C:\Users\hhhho\AppData\Local\Temp\EW128D.tmp
#        ("C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Components\stack\nwk\BindingTable.c" -D SECURE=1 -D xNV_INIT -D
#        xNV_RESTORE -D xPOWER_SAVING -D NWK_AUTO_POLL -D ZTOOL_P1 -D
#        LCD_SUPPORTED=FALSE -D MULTICAST_ENABLED=FALSE -D FEATURE_SYSTEM_STATS
#        -lC "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\EndDeviceEB\List" -lA
#        "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o
#        "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\EndDeviceEB\Obj" -e
#        --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\" -I
#        "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\Source\" -I
#        "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\Source\" -I
#        "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\EndDeviceEB\List\BindingTable.lst
#    Object file        =  
#        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD
#        -END\Projects\zstack\Prj\SampleApp\CC2530DB\EndDeviceEB\Obj\BindingTable.r51
#
###############################################################################

C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001-AD -END\Components\stack\nwk\BindingTable.c
      1          /**************************************************************************************************
      2            Filename:       BindingTable.c
      3            Revised:        $Date: 2014-10-08 08:37:03 -0700 (Wed, 08 Oct 2014) $
      4            Revision:       $Revision: 40512 $
      5          
      6            Description:    Device binding table functions.
      7          
      8          
      9            Copyright 2004-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Nv.h"
     46          #include "nwk_globals.h"
     47          #include "AddrMgr.h"
     48          #include "BindingTable.h"
     49          #include "nwk_util.h"
     50          
     51          /*********************************************************************
     52           * MACROS
     53           */
     54          
     55          /*********************************************************************
     56           * CONSTANTS
     57           */
     58          #define NV_BIND_EMPTY   0xFF
     59          #define NV_BIND_REC_SIZE (gBIND_REC_SIZE)
     60          #define NV_BIND_ITEM_SIZE  (gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES)
     61          
     62          /*********************************************************************
     63           * TYPEDEFS
     64           */
     65          typedef struct
     66          {
     67            uint8        srcEP;
     68            uint16       dstIndex;
     69            uint8        dstEP;
     70            uint8        dstAddrMode;
     71            uint8        clusterIDs;
     72            uint16*      clusterIDList;
     73          } bindFields_t;
     74          
     75          /*********************************************************************
     76           * GLOBAL VARIABLES
     77           */
     78          
     79          /*********************************************************************
     80           * LOCAL FUNCTIONS
     81           */
     82          void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryOld,
     83                              AddrMgrEntry_t *entryNew );
     84          BindingEntry_t *bindFindEmpty( void );
     85          uint16 bindingAddrMgsHelperFind( zAddrType_t *addr );
     86          uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr );
     87          void bindAddrMgrLocalLoad( void );
     88          
     89          #if !defined ( BINDINGTABLE_NV_SINGLES )
     90            #if !defined ( DONT_UPGRADE_BIND )
     91              static uint8 BindCopyBackupToNewNV( uint16 dupLen, uint16 newLen );
     92              static uint8 BindUpgradeTableInNV( void );
     93            #endif
     94          #endif // !BINDINGTABLE_NV_SINGLES
     95          
     96          
     97          /*********************************************************************
     98           * LOCAL VARIABLES
     99           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    100          static uint8 bindAddrMgrLocalLoaded = FALSE;
   \                     bindAddrMgrLocalLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    101          
    102          /*********************************************************************
    103           * Function Pointers
    104           */
    105          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    106          BindingEntry_t *(*pbindAddEntry)( byte srcEpInt,
   \                     pbindAddEntry:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    107                                            zAddrType_t *dstAddr, byte dstEpInt,
    108                                            byte numClusterIds, uint16 *clusterIds ) = (void*)NULL;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    109          uint16 (*pbindNumOfEntries)( void ) = (void*)NULL;
   \                     pbindNumOfEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    110          void (*pbindRemoveDev)( zAddrType_t *Addr ) = (void*)NULL;
   \                     pbindRemoveDev:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          byte (*pBindInitNV)( void ) = (void*)NULL;
   \                     pBindInitNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          void (*pBindSetDefaultNV)( void ) = (void*)NULL;
   \                     pBindSetDefaultNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          uint16 (*pBindRestoreFromNV)( void ) = (void*)NULL;
   \                     pBindRestoreFromNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    114          void (*pBindWriteNV)( void ) = (void*)NULL;
   \                     pBindWriteNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    115          
    116          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
    117          /*********************************************************************
    118           * @fn      BindAddrMgrCB()
    119           *
    120           * @brief   Address Manager Callback function
    121           *
    122           * @param   update -
    123           * @param   entry -
    124           *
    125           * @return  pointer to
    126           */
    127          void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryNew,
    128                              AddrMgrEntry_t *entryOld )
    129          {
    130            // Check for either deleted items or changed Extended (Duplicate) addresses
    131          }
    132          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
    133          
    134          /*********************************************************************
    135           * @fn      InitBindingTable()
    136           *
    137           * @brief
    138           *
    139           *   This function is used to initialise the binding table
    140           *
    141           * @param   none
    142           *
    143           * @return  none
    144           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void InitBindingTable( void )
   \                     InitBindingTable:
    146          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    147            osal_memset( BindingTable, 0xFF, gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES );
   \   000005                ; Setup parameters for call to function osal_memset
   \   000005   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000008   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000B   E4           CLR       A
   \   00000C   93           MOVC      A,@A+DPTR
   \   00000D   F5..         MOV       ?V0,A
   \   00000F   EC           MOV       A,R4
   \   000010   85..F0       MOV       B,?V0
   \   000013   A4           MUL       AB
   \   000014   FC           MOV       R4,A
   \   000015   A8F0         MOV       R0,B
   \   000017   85..F0       MOV       B,?V0
   \   00001A   ED           MOV       A,R5
   \   00001B   A4           MUL       AB
   \   00001C   28           ADD       A,R0
   \   00001D   FD           MOV       R5,A
   \   00001E   79FF         MOV       R1,#-0x1
   \   000020   7A..         MOV       R2,#BindingTable & 0xff
   \   000022   7B..         MOV       R3,#(BindingTable >> 8) & 0xff
   \   000024   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    148          
    149            pbindAddEntry = bindAddEntry;
   \   000027   90....       MOV       DPTR,#pbindAddEntry
   \   00002A   74..         MOV       A,#`??bindAddEntry::?relay` & 0xff
   \   00002C   F0           MOVX      @DPTR,A
   \   00002D   A3           INC       DPTR
   \   00002E   74..         MOV       A,#(`??bindAddEntry::?relay` >> 8) & 0xff
   \   000030   F0           MOVX      @DPTR,A
    150            pbindNumOfEntries = bindNumOfEntries;
   \   000031   90....       MOV       DPTR,#pbindNumOfEntries
   \   000034   74..         MOV       A,#`??bindNumOfEntries::?relay` & 0xff
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   74..         MOV       A,#(`??bindNumOfEntries::?relay` >> 8) & 0xff
   \   00003A   F0           MOVX      @DPTR,A
    151            pbindRemoveDev = bindRemoveDev;
   \   00003B   90....       MOV       DPTR,#pbindRemoveDev
   \   00003E   74..         MOV       A,#`??bindRemoveDev::?relay` & 0xff
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   74..         MOV       A,#(`??bindRemoveDev::?relay` >> 8) & 0xff
   \   000044   F0           MOVX      @DPTR,A
    152            pBindInitNV = BindInitNV;
   \   000045   90....       MOV       DPTR,#pBindInitNV
   \   000048   74..         MOV       A,#`??BindInitNV::?relay` & 0xff
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   A3           INC       DPTR
   \   00004C   74..         MOV       A,#(`??BindInitNV::?relay` >> 8) & 0xff
   \   00004E   F0           MOVX      @DPTR,A
    153            pBindSetDefaultNV = BindSetDefaultNV;
   \   00004F   90....       MOV       DPTR,#pBindSetDefaultNV
   \   000052   74..         MOV       A,#`??BindSetDefaultNV::?relay` & 0xff
   \   000054   F0           MOVX      @DPTR,A
   \   000055   A3           INC       DPTR
   \   000056   74..         MOV       A,#(`??BindSetDefaultNV::?relay` >> 8) & 0xff
   \   000058   F0           MOVX      @DPTR,A
    154            pBindRestoreFromNV = BindRestoreFromNV;
   \   000059   90....       MOV       DPTR,#pBindRestoreFromNV
   \   00005C   74..         MOV       A,#`??BindRestoreFromNV::?relay` & 0xff
   \   00005E   F0           MOVX      @DPTR,A
   \   00005F   A3           INC       DPTR
   \   000060   74..         MOV       A,#(`??BindRestoreFromNV::?relay` >> 8) & 0xff
   \   000062   F0           MOVX      @DPTR,A
    155            pBindWriteNV = BindWriteNV;
   \   000063   90....       MOV       DPTR,#pBindWriteNV
   \   000066   74..         MOV       A,#`??BindWriteNV::?relay` & 0xff
   \   000068   F0           MOVX      @DPTR,A
   \   000069   A3           INC       DPTR
   \   00006A   74..         MOV       A,#(`??BindWriteNV::?relay` >> 8) & 0xff
   \   00006C   F0           MOVX      @DPTR,A
    156          
    157            bindAddrMgrLocalLoaded = FALSE;
   \   00006D   90....       MOV       DPTR,#bindAddrMgrLocalLoaded
   \   000070   E4           CLR       A
   \   000071   F0           MOVX      @DPTR,A
    158          
    159          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
    160            // Register with the address manager
    161            AddrMgrRegister( ADDRMGR_REG_BINDING, BindAddrMgrCB );
    162          #endif
    163          }
   \   000072   80..         SJMP      ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   FC           MOV       R4,A
   \   000006   7401         MOV       A,#0x1
   \   000008   93           MOVC      A,@A+DPTR
   \   000009   FD           MOV       R5,A
   \   00000A   22           RET
    164          
    165          /*********************************************************************
    166           * @fn      bindFindEmpty()
    167           *
    168           * @brief   This function returns a pointer to an empty binding slot
    169           *
    170           * @param   none
    171           *
    172           * @return  pointer to binding table entry, NULL if not added
    173           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    174          BindingEntry_t *bindFindEmpty( void )
   \                     bindFindEmpty:
    175          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    176            bindTableIndex_t x;
    177          
    178            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000004   7A00         MOV       R2,#0x0
   \   000006   8001         SJMP      ??bindFindEmpty_0
   \                     ??bindFindEmpty_1:
   \   000008   0A           INC       R2
   \                     ??bindFindEmpty_0:
   \   000009   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000C   E4           CLR       A
   \   00000D   93           MOVC      A,@A+DPTR
   \   00000E   F8           MOV       R0,A
   \   00000F   EA           MOV       A,R2
   \   000010   C3           CLR       C
   \   000011   98           SUBB      A,R0
   \   000012   500C         JNC       ??bindFindEmpty_2
    179            {
    180              // It's empty if the index is "Not Found"
    181              if ( BindingTable[x].srcEP == NV_BIND_EMPTY )
   \   000014   EA           MOV       A,R2
   \   000015   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000018   70EE         JNZ       ??bindFindEmpty_1
    182              {
    183                return ( &BindingTable[x] );
   \   00001A   AA82         MOV       R2,DPL
   \   00001C   AB83         MOV       R3,DPH
   \   00001E   8004         SJMP      ??bindFindEmpty_3
    184              }
    185            }
    186          
    187            return ( (BindingEntry_t *)NULL );
   \                     ??bindFindEmpty_2:
   \   000020   7A00         MOV       R2,#0x0
   \   000022   7B00         MOV       R3,#0x0
   \                     ??bindFindEmpty_3:
   \   000024   02....       LJMP      ??Subroutine40_0 & 0xFFFF
    188          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   75F00E       MOV       B,#0xe
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007                REQUIRE ??Subroutine35_0
   \   000007                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   F4           CPL       A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   74..         MOV       A,#BindingTable & 0xff
   \   000002   28           ADD       A,R0
   \   000003   F582         MOV       DPL,A
   \   000005   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000007   39           ADDC      A,R1
   \   000008   F583         MOV       DPH,A
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    189          
    190          /*********************************************************************
    191           * @fn      bindNumOfEntries()
    192           *
    193           * @brief   This function returns the number of binding table entries.
    194           *          The return for this is the number of clusters in the
    195           *          table NOT the number of entries.
    196           *
    197           * @param   none
    198           *
    199           * @return  number of entries
    200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    201          uint16 bindNumOfEntries( void )
   \                     bindNumOfEntries:
    202          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    203            bindTableIndex_t x;
    204            uint16 found;
    205          
    206            for ( found = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000004   7A00         MOV       R2,#0x0
   \   000006   7B00         MOV       R3,#0x0
   \   000008   7C00         MOV       R4,#0x0
   \   00000A   8014         SJMP      ??bindNumOfEntries_0
    207            {
    208              // It's empty if the index is "Not Found"
    209              if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \                     ??bindNumOfEntries_1:
   \   00000C   EC           MOV       A,R4
   \   00000D   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000010   600D         JZ        ??bindNumOfEntries_2
    210              {
    211                found += BindingTable[x].numClusterIds;
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   EA           MOV       A,R2
   \   00001A   28           ADD       A,R0
   \   00001B   FA           MOV       R2,A
   \   00001C   E4           CLR       A
   \   00001D   3B           ADDC      A,R3
   \   00001E   FB           MOV       R3,A
    212              }
    213            }
   \                     ??bindNumOfEntries_2:
   \   00001F   0C           INC       R4
   \                     ??bindNumOfEntries_0:
   \   000020   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000023   E4           CLR       A
   \   000024   93           MOVC      A,@A+DPTR
   \   000025   F8           MOV       R0,A
   \   000026   EC           MOV       A,R4
   \   000027   C3           CLR       C
   \   000028   98           SUBB      A,R0
   \   000029   40E1         JC        ??bindNumOfEntries_1
    214          
    215            return ( found );
   \   00002B   02....       LJMP      ??Subroutine40_0 & 0xFFFF
    216          }
    217          
    218          /*********************************************************************
    219           * @fn      bindCapacity()
    220           *
    221           * @brief   This function returns the number of binding entries
    222           *          possible and used.
    223           *
    224           * @param   maxEntries - pointer to a place to put the max entries
    225           * @param   usedEntries - pointer to a place to put the number
    226           *               of used entries
    227           *
    228           * @return  none
    229           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          void bindCapacity( uint16 *maxEntries, uint16 *usedEntries  )
   \                     bindCapacity:
    231          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    232            bindTableIndex_t x;
    233            bindTableIndex_t used;
    234          
    235            for ( used = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000005   7F00         MOV       R7,#0x0
   \   000007   7E00         MOV       R6,#0x0
   \   000009   8012         SJMP      ??bindCapacity_0
    236            {
    237              // It's empty if the index is "Not Found"
    238              if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \                     ??bindCapacity_1:
   \   00000B   EE           MOV       A,R6
   \   00000C   75F00E       MOV       B,#0xe
   \   00000F   A4           MUL       AB
   \   000010   F8           MOV       R0,A
   \   000011   85F0..       MOV       ?V0,B
   \   000014   A9..         MOV       R1,?V0
   \   000016   12....       LCALL     ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000019   6001         JZ        ??bindCapacity_2
    239              {
    240                used++;
   \   00001B   0F           INC       R7
    241              }
    242            }
   \                     ??bindCapacity_2:
   \   00001C   0E           INC       R6
   \                     ??bindCapacity_0:
   \   00001D   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000020   E4           CLR       A
   \   000021   93           MOVC      A,@A+DPTR
   \   000022   F8           MOV       R0,A
   \   000023   EE           MOV       A,R6
   \   000024   C3           CLR       C
   \   000025   98           SUBB      A,R0
   \   000026   40E3         JC        ??bindCapacity_1
    243          
    244            *maxEntries = gNWK_MAX_BINDING_ENTRIES;
   \   000028   E4           CLR       A
   \   000029   93           MOVC      A,@A+DPTR
   \   00002A   8A82         MOV       DPL,R2
   \   00002C   8B83         MOV       DPH,R3
   \   00002E   F0           MOVX      @DPTR,A
   \   00002F   A3           INC       DPTR
   \   000030   E4           CLR       A
   \   000031   F0           MOVX      @DPTR,A
    245            *usedEntries = used;
   \   000032   EF           MOV       A,R7
   \   000033   8C82         MOV       DPL,R4
   \   000035   8D83         MOV       DPH,R5
   \   000037   F0           MOVX      @DPTR,A
   \   000038   A3           INC       DPTR
   \   000039   E4           CLR       A
   \   00003A   F0           MOVX      @DPTR,A
    246          }
   \   00003B   02....       LJMP      ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    247          
    248          /*********************************************************************
    249           * @fn      bindAddEntry()
    250           *
    251           * @brief   This function is used to Add an entry to the binding table
    252           *
    253           * @param       srcEpInt - source endpoint
    254           * @param       dstAddr - destination Address
    255           * @param       dstEpInt - destination endpoint
    256           * @param       numClusterIds - number of cluster Ids in the list
    257           * @param       clusterIds - pointer to the Object ID list
    258           *
    259           * @return  pointer to binding table entry, NULL if not added
    260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    261          BindingEntry_t *bindAddEntry( byte srcEpInt,
   \                     bindAddEntry:
    262                                        zAddrType_t *dstAddr, byte dstEpInt,
    263                                        byte numClusterIds, uint16 *clusterIds )
    264          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V6,R2
   \   000009   8B..         MOV       ?V7,R3
   \   00000B   8C..         MOV       ?V8,R4
   \   00000D   8D..         MOV       ?V0,R5
    265            uint8            index;
    266            bindTableIndex_t bindIdx;
    267            BindingEntry_t*  entry;
    268            bindFields_t     fields;
    269          
    270            // initialize results
    271            entry = NULL;
   \   00000F   7E00         MOV       R6,#0x0
   \   000011   7F00         MOV       R7,#0x0
    272          
    273            // make sure local addresses have been loaded
    274            bindAddrMgrLocalLoad();
   \   000013                ; Setup parameters for call to function bindAddrMgrLocalLoad
   \   000013   12....       LCALL     `??bindAddrMgrLocalLoad::?relay`; Banked call to: bindAddrMgrLocalLoad
    275          
    276            // setup fields
    277            fields.dstIndex = bindAddrIndexGet( dstAddr );
   \   000016                ; Setup parameters for call to function bindAddrIndexGet
   \   000016   AA..         MOV       R2,?V6
   \   000018   AB..         MOV       R3,?V7
   \   00001A   12....       LCALL     `??bindAddrIndexGet::?relay`; Banked call to: bindAddrIndexGet
   \   00001D   8A..         MOV       ?V4,R2
   \   00001F   8B..         MOV       ?V5,R3
    278            fields.srcEP    = srcEpInt;
    279          
    280            if ( dstAddr->addrMode == AddrGroup )
   \   000021   85..82       MOV       DPL,?V6
   \   000024   85..83       MOV       DPH,?V7
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   6401         XRL       A,#0x1
   \   000032   7008         JNZ       ??bindAddEntry_0
    281            {
    282              fields.dstAddrMode = DSTGROUPMODE_GROUP;
   \   000034   75..01       MOV       ?V3,#0x1
    283              fields.dstEP       = 0;
   \   000037   75..00       MOV       ?V1,#0x0
   \   00003A   8006         SJMP      ??bindAddEntry_1
    284            }
    285            else
    286            {
    287              fields.dstAddrMode = DSTGROUPMODE_ADDR;
   \                     ??bindAddEntry_0:
   \   00003C   75..00       MOV       ?V3,#0x0
    288              fields.dstEP       = dstEpInt;
   \   00003F   85....       MOV       ?V1,?V8
    289            }
    290          
    291            if ( fields.dstIndex != INVALID_NODE_ADDR  )
   \                     ??bindAddEntry_1:
   \   000042   74FE         MOV       A,#-0x2
   \   000044   6A           XRL       A,R2
   \   000045   7003         JNZ       ??bindAddEntry_2
   \   000047   74FF         MOV       A,#-0x1
   \   000049   6B           XRL       A,R3
   \                     ??bindAddEntry_2:
   \   00004A   7003         JNZ       $+5
   \   00004C   02....       LJMP      ??bindAddEntry_3 & 0xFFFF
    292            {
    293              for ( bindIdx = 0; bindIdx < gNWK_MAX_BINDING_ENTRIES; bindIdx++ )
   \   00004F   7A00         MOV       R2,#0x0
   \   000051   7414         MOV       A,#0x14
   \   000053   12....       LCALL     ?XSTACK_DISP0_8
   \   000056   E0           MOVX      A,@DPTR
   \   000057   F5..         MOV       ?V6,A
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   F5..         MOV       ?V7,A
   \   00005D   8001         SJMP      ??bindAddEntry_4
   \                     ??bindAddEntry_5:
   \   00005F   0A           INC       R2
   \                     ??bindAddEntry_4:
   \   000060   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000063   E4           CLR       A
   \   000064   93           MOVC      A,@A+DPTR
   \   000065   F8           MOV       R0,A
   \   000066   EA           MOV       A,R2
   \   000067   C3           CLR       C
   \   000068   98           SUBB      A,R0
   \   000069   506F         JNC       ??bindAddEntry_6
    294              {
    295                if ( ( fields.srcEP       == BindingTable[bindIdx].srcEP        ) &&
    296                     ( fields.dstAddrMode == BindingTable[bindIdx].dstGroupMode ) &&
    297                     ( fields.dstIndex    == BindingTable[bindIdx].dstIdx       ) &&
    298                     ( fields.dstEP       == BindingTable[bindIdx].dstEP        )    )
   \   00006B   EA           MOV       A,R2
   \   00006C   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00006F   65..         XRL       A,?V2
   \   000071   70EC         JNZ       ??bindAddEntry_5
   \   000073   A3           INC       DPTR
   \   000074   E0           MOVX      A,@DPTR
   \   000075   65..         XRL       A,?V3
   \   000077   70E6         JNZ       ??bindAddEntry_5
   \   000079   8E82         MOV       DPL,R6
   \   00007B   8F83         MOV       DPH,R7
   \   00007D   A3           INC       DPTR
   \   00007E   A3           INC       DPTR
   \   00007F   E0           MOVX      A,@DPTR
   \   000080   65..         XRL       A,?V4
   \   000082   7003         JNZ       ??bindAddEntry_7
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   6B           XRL       A,R3
   \                     ??bindAddEntry_7:
   \   000087   70D6         JNZ       ??bindAddEntry_5
   \   000089   8E82         MOV       DPL,R6
   \   00008B   8F83         MOV       DPH,R7
   \   00008D   A3           INC       DPTR
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   E0           MOVX      A,@DPTR
   \   000092   65..         XRL       A,?V1
   \   000094   70C9         JNZ       ??bindAddEntry_5
    299                {
    300                  entry = &BindingTable[bindIdx];
    301          
    302                  // break from loop
    303                  break;
    304                }
    305              }
    306          
    307              if ( entry != NULL )
    308              {
    309                // Loop through the cluster IDs
    310                for ( index = 0; index < numClusterIds; index++ )
   \   000096   75..00       MOV       ?V3,#0x0
   \                     ??bindAddEntry_8:
   \   000099   E5..         MOV       A,?V3
   \   00009B   C3           CLR       C
   \   00009C   95..         SUBB      A,?V0
   \   00009E   4003         JC        $+5
   \   0000A0   02....       LJMP      ??bindAddEntry_3 & 0xFFFF
    311                {
    312                  // Found - is the cluster already defined?
    313                  if ( bindIsClusterIDinList( entry, clusterIds[index] ) == FALSE )
   \   0000A3   A8..         MOV       R0,?V3
   \   0000A5   E8           MOV       A,R0
   \   0000A6   28           ADD       A,R0
   \   0000A7   F8           MOV       R0,A
   \   0000A8   E4           CLR       A
   \   0000A9   33           RLC       A
   \   0000AA   F9           MOV       R1,A
   \   0000AB   E5..         MOV       A,?V6
   \   0000AD   28           ADD       A,R0
   \   0000AE   F5..         MOV       ?V4,A
   \   0000B0   E5..         MOV       A,?V7
   \   0000B2   39           ADDC      A,R1
   \   0000B3   F5..         MOV       ?V5,A
   \   0000B5                ; Setup parameters for call to function bindIsClusterIDinList
   \   0000B5   85..82       MOV       DPL,?V4
   \   0000B8   F583         MOV       DPH,A
   \   0000BA   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   0000BD   12....       LCALL     `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   0000C0   E9           MOV       A,R1
   \   0000C1   7013         JNZ       ??bindAddEntry_9
    314                  {
    315                    // Nope, add this cluster
    316                    if ( bindAddClusterIdToList( entry, clusterIds[index] ) == FALSE )
   \   0000C3                ; Setup parameters for call to function bindAddClusterIdToList
   \   0000C3   85..82       MOV       DPL,?V4
   \   0000C6   85..83       MOV       DPH,?V5
   \   0000C9   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0000CC   12....       LCALL     `??bindAddClusterIdToList::?relay`; Banked call to: bindAddClusterIdToList
   \   0000CF   E9           MOV       A,R1
   \   0000D0   7004         JNZ       ??bindAddEntry_9
    317                    {
    318                      // Indicate error if cluster list was full
    319                      entry = NULL;
   \   0000D2   7E00         MOV       R6,#0x0
   \   0000D4   7F00         MOV       R7,#0x0
    320                    }
    321                  }
    322                }
   \                     ??bindAddEntry_9:
   \   0000D6   05..         INC       ?V3
   \   0000D8   80BF         SJMP      ??bindAddEntry_8
    323              }
    324              else
    325              {
    326                // Find an empty slot
    327                entry = bindFindEmpty();
   \                     ??bindAddEntry_6:
   \   0000DA                ; Setup parameters for call to function bindFindEmpty
   \   0000DA   12....       LCALL     `??bindFindEmpty::?relay`; Banked call to: bindFindEmpty
   \   0000DD   8A..         MOV       ?V10,R2
   \   0000DF   8B..         MOV       ?V11,R3
   \   0000E1   AE..         MOV       R6,?V10
   \   0000E3   AF..         MOV       R7,?V11
    328          
    329                // Check against the maximum number allowed
    330                if ( entry != NULL )
   \   0000E5   EA           MOV       A,R2
   \   0000E6   4F           ORL       A,R7
   \   0000E7   605C         JZ        ??bindAddEntry_3
    331                {
    332                  // Add new entry
    333                  entry->srcEP         = fields.srcEP;
   \   0000E9   8A82         MOV       DPL,R2
   \   0000EB   8B83         MOV       DPH,R3
   \   0000ED   E5..         MOV       A,?V2
   \   0000EF   F0           MOVX      @DPTR,A
    334                  entry->dstGroupMode  = fields.dstAddrMode;
   \   0000F0   A3           INC       DPTR
   \   0000F1   E5..         MOV       A,?V3
   \   0000F3   F0           MOVX      @DPTR,A
    335                  entry->dstIdx        = fields.dstIndex;
   \   0000F4   8A82         MOV       DPL,R2
   \   0000F6   8B83         MOV       DPH,R3
   \   0000F8   A3           INC       DPTR
   \   0000F9   A3           INC       DPTR
   \   0000FA   E5..         MOV       A,?V4
   \   0000FC   F0           MOVX      @DPTR,A
   \   0000FD   A3           INC       DPTR
   \   0000FE   E5..         MOV       A,?V5
   \   000100   12....       LCALL     ?Subroutine30 & 0xFFFF
    336                  entry->dstEP         = fields.dstEP;
   \                     ??CrossCallReturnLabel_38:
   \   000103   E5..         MOV       A,?V1
   \   000105   F0           MOVX      @DPTR,A
    337          
    338                  if ( numClusterIds > gMAX_BINDING_CLUSTER_IDS )
   \   000106   90....       MOV       DPTR,#gMAX_BINDING_CLUSTER_IDS
   \   000109   E4           CLR       A
   \   00010A   93           MOVC      A,@A+DPTR
   \   00010B   C3           CLR       C
   \   00010C   95..         SUBB      A,?V0
   \   00010E   5004         JNC       ??bindAddEntry_10
    339                  {
    340                    numClusterIds = gMAX_BINDING_CLUSTER_IDS;
   \   000110   E4           CLR       A
   \   000111   93           MOVC      A,@A+DPTR
   \   000112   F5..         MOV       ?V0,A
    341                  }
    342          
    343                  entry->numClusterIds = numClusterIds;
   \                     ??bindAddEntry_10:
   \   000114   8A82         MOV       DPL,R2
   \   000116   8B83         MOV       DPH,R3
   \   000118   A3           INC       DPTR
   \   000119   A3           INC       DPTR
   \   00011A   A3           INC       DPTR
   \   00011B   A3           INC       DPTR
   \   00011C   A3           INC       DPTR
   \   00011D   E5..         MOV       A,?V0
   \   00011F   F0           MOVX      @DPTR,A
    344          
    345                  osal_memcpy( entry->clusterIdList,
    346                               clusterIds,
    347                               numClusterIds * sizeof(uint16) );
   \   000120                ; Setup parameters for call to function osal_memcpy
   \   000120   85....       MOV       ?V4,?V6
   \   000123   85....       MOV       ?V5,?V7
   \   000126   75..00       MOV       ?V6,#0x0
   \   000129   78..         MOV       R0,#?V4
   \   00012B   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00012E   AC..         MOV       R4,?V0
   \   000130   EC           MOV       A,R4
   \   000131   2C           ADD       A,R4
   \   000132   FC           MOV       R4,A
   \   000133   E4           CLR       A
   \   000134   33           RLC       A
   \   000135   FD           MOV       R5,A
   \   000136   EA           MOV       A,R2
   \   000137   2406         ADD       A,#0x6
   \   000139   FA           MOV       R2,A
   \   00013A   E4           CLR       A
   \   00013B   3F           ADDC      A,R7
   \   00013C   FB           MOV       R3,A
   \   00013D   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000140   7403         MOV       A,#0x3
   \   000142   12....       LCALL     ?DEALLOC_XSTACK8
    348                }
    349              }
    350            }
    351          
    352            return entry;
   \                     ??bindAddEntry_3:
   \   000145   EE           MOV       A,R6
   \   000146   FA           MOV       R2,A
   \   000147   EF           MOV       A,R7
   \   000148   FB           MOV       R3,A
   \   000149   7F0C         MOV       R7,#0xc
   \   00014B   02....       LJMP      ?BANKED_LEAVE_XDATA
    353          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   EE           MOV       A,R6
   \   000006   FA           MOV       R2,A
   \   000007   EF           MOV       A,R7
   \   000008   FB           MOV       R3,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   75F00E       MOV       B,#0xe
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007   74..         MOV       A,#BindingTable & 0xff
   \   000009   28           ADD       A,R0
   \   00000A   FE           MOV       R6,A
   \   00000B   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   00000D   39           ADDC      A,R1
   \   00000E   FF           MOV       R7,A
   \   00000F   8E82         MOV       DPL,R6
   \   000011   F583         MOV       DPH,A
   \   000013   E0           MOVX      A,@DPTR
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET
    354          
    355          /*********************************************************************
    356           * @fn      bindRemoveEntry
    357           *
    358           * @brief   Removes a binding table entry.
    359           *
    360           * @param   pBind - pointer to binding table entry to delete
    361           *
    362           * @return  TRUE if Removed, FALSE if not
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          byte bindRemoveEntry( BindingEntry_t *pBind )
   \                     bindRemoveEntry:
    365          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    366            osal_memset( pBind, 0xFF, gBIND_REC_SIZE );
   \   000004                ; Setup parameters for call to function osal_memset
   \   000004   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000007   79FF         MOV       R1,#-0x1
   \   000009   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    367            return ( TRUE );
   \   00000C   7901         MOV       R1,#0x1
   \   00000E   02....       LJMP      ??Subroutine40_0 & 0xFFFF
    368          }
    369          
    370          /*********************************************************************
    371           * @fn      bindIsClusterIDinList()
    372           *
    373           * @brief   Is the clusterID in the clusterID list?
    374           *
    375           * @param   enter - binding table entry
    376           * @param   clusterId  - Cluster ID to look for
    377           *
    378           * @return  TRUE if found, FALSE if not found
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          byte bindIsClusterIDinList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindIsClusterIDinList:
    381          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    382            uint8 x;
    383          
    384            if ( entry != NULL )
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   6037         JZ        ??bindIsClusterIDinList_0
    385            {
    386              for ( x = 0; x < entry->numClusterIds; x++ )
   \   000009   7E00         MOV       R6,#0x0
   \   00000B   8001         SJMP      ??bindIsClusterIDinList_1
   \                     ??bindIsClusterIDinList_2:
   \   00000D   0E           INC       R6
   \                     ??bindIsClusterIDinList_1:
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   EE           MOV       A,R6
   \   00001A   C3           CLR       C
   \   00001B   98           SUBB      A,R0
   \   00001C   5022         JNC       ??bindIsClusterIDinList_0
    387              {
    388                if ( entry->clusterIdList[x] == clusterId )
   \   00001E   EE           MOV       A,R6
   \   00001F   25E0         ADD       A,0xE0 /* A   */
   \   000021   F8           MOV       R0,A
   \   000022   E4           CLR       A
   \   000023   33           RLC       A
   \   000024   F9           MOV       R1,A
   \   000025   EA           MOV       A,R2
   \   000026   28           ADD       A,R0
   \   000027   F582         MOV       DPL,A
   \   000029   EB           MOV       A,R3
   \   00002A   39           ADDC      A,R1
   \   00002B   F583         MOV       DPH,A
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6C           XRL       A,R4
   \   000035   7003         JNZ       ??bindIsClusterIDinList_3
   \   000037   A3           INC       DPTR
   \   000038   E0           MOVX      A,@DPTR
   \   000039   6D           XRL       A,R5
   \                     ??bindIsClusterIDinList_3:
   \   00003A   70D1         JNZ       ??bindIsClusterIDinList_2
    389                {
    390                  return ( TRUE );
   \   00003C   7901         MOV       R1,#0x1
   \   00003E   8002         SJMP      ??bindIsClusterIDinList_4
    391                }
    392              }
    393            }
    394          
    395            return ( FALSE );
   \                     ??bindIsClusterIDinList_0:
   \   000040   7900         MOV       R1,#0x0
   \                     ??bindIsClusterIDinList_4:
   \   000042   02....       LJMP      ?Subroutine2 & 0xFFFF
    396          }
    397          
    398          /*********************************************************************
    399           * @fn      bindRemoveClusterIdFromList()
    400           *
    401           * @brief   Removes a ClusterID from a list of ClusterIDs.
    402           *
    403           * @param   enter - binding table entry
    404           * @param   clusterId  - Cluster ID to look for
    405           *
    406           * @return  TRUE if there are at least 1 clusterID left, FALSE if none
    407           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          byte bindRemoveClusterIdFromList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindRemoveClusterIdFromList:
    409          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV       A,#-0xd
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
    410            byte x;
    411            uint16 *listPtr;
    412            byte numIds;
    413          
    414            if ( entry )
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   6075         JZ        ??bindRemoveClusterIdFromList_0
    415            {
    416              if ( entry->numClusterIds > 0 )
   \   000009   EA           MOV       A,R2
   \   00000A   2405         ADD       A,#0x5
   \   00000C   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00000F   F5..         MOV       ?V0,A
   \   000011   606B         JZ        ??bindRemoveClusterIdFromList_0
    417              {
    418                listPtr = entry->clusterIdList;
   \   000013   EA           MOV       A,R2
   \   000014   2406         ADD       A,#0x6
   \   000016   08           INC       R0
   \   000017   E4           CLR       A
   \   000018   3B           ADDC      A,R3
   \   000019   F9           MOV       R1,A
    419                numIds = entry->numClusterIds;
   \   00001A   85....       MOV       ?V3,?V0
    420          
    421                // Copy the new list over
    422                for ( x = 0; x < numIds; x++ )
   \   00001D   75..00       MOV       ?V2,#0x0
   \   000020   800B         SJMP      ??bindRemoveClusterIdFromList_1
    423                {
    424                  if ( entry->clusterIdList[x] != clusterId )
    425                  {
    426                    *listPtr++ = entry->clusterIdList[x];
    427                  }
    428                  else
    429                  {
    430                    entry->numClusterIds--;
   \                     ??bindRemoveClusterIdFromList_2:
   \   000022   8E82         MOV       DPL,R6
   \   000024   8F83         MOV       DPH,R7
   \   000026   E0           MOVX      A,@DPTR
   \   000027   14           DEC       A
   \   000028   F0           MOVX      @DPTR,A
    431                    if ( entry->numClusterIds == 0 )
   \   000029   6053         JZ        ??bindRemoveClusterIdFromList_0
    432                    {
    433                      break;
    434                    }
    435                  }
   \                     ??bindRemoveClusterIdFromList_3:
   \   00002B   05..         INC       ?V2
   \                     ??bindRemoveClusterIdFromList_1:
   \   00002D   E5..         MOV       A,?V2
   \   00002F   C3           CLR       C
   \   000030   95..         SUBB      A,?V3
   \   000032   503F         JNC       ??bindRemoveClusterIdFromList_4
   \   000034   E5..         MOV       A,?V2
   \   000036   25E0         ADD       A,0xE0 /* A   */
   \   000038   F5..         MOV       ?V0,A
   \   00003A   E4           CLR       A
   \   00003B   33           RLC       A
   \   00003C   F5..         MOV       ?V1,A
   \   00003E   EA           MOV       A,R2
   \   00003F   25..         ADD       A,?V0
   \   000041   F582         MOV       DPL,A
   \   000043   EB           MOV       A,R3
   \   000044   35..         ADDC      A,?V1
   \   000046   F583         MOV       DPH,A
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   A3           INC       DPTR
   \   00004D   A3           INC       DPTR
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   F5..         MOV       ?V0,A
   \   000051   A3           INC       DPTR
   \   000052   E0           MOVX      A,@DPTR
   \   000053   F5..         MOV       ?V1,A
   \   000055   EC           MOV       A,R4
   \   000056   65..         XRL       A,?V0
   \   000058   7003         JNZ       ??bindRemoveClusterIdFromList_5
   \   00005A   ED           MOV       A,R5
   \   00005B   65..         XRL       A,?V1
   \                     ??bindRemoveClusterIdFromList_5:
   \   00005D   60C3         JZ        ??bindRemoveClusterIdFromList_2
   \   00005F   8882         MOV       DPL,R0
   \   000061   8983         MOV       DPH,R1
   \   000063   E5..         MOV       A,?V0
   \   000065   F0           MOVX      @DPTR,A
   \   000066   A3           INC       DPTR
   \   000067   E5..         MOV       A,?V1
   \   000069   F0           MOVX      @DPTR,A
   \   00006A   E8           MOV       A,R0
   \   00006B   2402         ADD       A,#0x2
   \   00006D   F8           MOV       R0,A
   \   00006E   50BB         JNC       ??bindRemoveClusterIdFromList_3
   \   000070   09           INC       R1
   \   000071   80B8         SJMP      ??bindRemoveClusterIdFromList_3
    436                }
    437              }
    438            }
   \                     ??bindRemoveClusterIdFromList_4:
   \   000073   8E82         MOV       DPL,R6
   \   000075   8F83         MOV       DPH,R7
   \   000077   E0           MOVX      A,@DPTR
   \   000078   6004         JZ        ??bindRemoveClusterIdFromList_0
    439          
    440            if ( entry && (entry->numClusterIds > 0) )
    441            {
    442              return ( TRUE );
   \   00007A   7901         MOV       R1,#0x1
   \   00007C   8002         SJMP      ??bindRemoveClusterIdFromList_6
    443            }
    444            else
    445            {
    446              return ( FALSE );
   \                     ??bindRemoveClusterIdFromList_0:
   \   00007E   7900         MOV       R1,#0x0
    447            }
   \                     ??bindRemoveClusterIdFromList_6:
   \   000080                REQUIRE ?Subroutine3
   \   000080                ; // Fall through to label ?Subroutine3
    448          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F05         MOV       R7,#0x5
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   F8           MOV       R0,A
   \   000001   E4           CLR       A
   \   000002   3B           ADDC      A,R3
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   FE           MOV       R6,A
   \   000006   E9           MOV       A,R1
   \   000007   FF           MOV       R7,A
   \   000008   8882         MOV       DPL,R0
   \   00000A   F583         MOV       DPH,A
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   22           RET
    449          
    450          /*********************************************************************
    451           * @fn      bindAddClusterIdToList()
    452           *
    453           * @brief   Adds a ClusterID to a list of ClusterIDs.
    454           *
    455           * @param   enter - binding table entry
    456           * @param   clusterId  - Cluster ID to Add
    457           *
    458           * @return  TRUE if Added, FALSE if not
    459           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    460          byte bindAddClusterIdToList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindAddClusterIdToList:
    461          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    462            if ( entry && entry->numClusterIds < gMAX_BINDING_CLUSTER_IDS )
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   603C         JZ        ??bindAddClusterIdToList_0
   \   000009   EA           MOV       A,R2
   \   00000A   2405         ADD       A,#0x5
   \   00000C   F8           MOV       R0,A
   \   00000D   E4           CLR       A
   \   00000E   3B           ADDC      A,R3
   \   00000F   F9           MOV       R1,A
   \   000010   8882         MOV       DPL,R0
   \   000012   F583         MOV       DPH,A
   \   000014   E0           MOVX      A,@DPTR
   \   000015   FE           MOV       R6,A
   \   000016   90....       MOV       DPTR,#gMAX_BINDING_CLUSTER_IDS
   \   000019   E4           CLR       A
   \   00001A   93           MOVC      A,@A+DPTR
   \   00001B   FF           MOV       R7,A
   \   00001C   EE           MOV       A,R6
   \   00001D   C3           CLR       C
   \   00001E   9F           SUBB      A,R7
   \   00001F   5024         JNC       ??bindAddClusterIdToList_0
    463            {
    464              // Add the new one
    465              entry->clusterIdList[entry->numClusterIds] = clusterId;
   \   000021   EE           MOV       A,R6
   \   000022   2E           ADD       A,R6
   \   000023   FE           MOV       R6,A
   \   000024   E4           CLR       A
   \   000025   33           RLC       A
   \   000026   FF           MOV       R7,A
   \   000027   EA           MOV       A,R2
   \   000028   2E           ADD       A,R6
   \   000029   F582         MOV       DPL,A
   \   00002B   EB           MOV       A,R3
   \   00002C   3F           ADDC      A,R7
   \   00002D   F583         MOV       DPH,A
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   EC           MOV       A,R4
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   ED           MOV       A,R5
   \   000039   F0           MOVX      @DPTR,A
    466              entry->numClusterIds++;
   \   00003A   8882         MOV       DPL,R0
   \   00003C   8983         MOV       DPH,R1
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   04           INC       A
   \   000040   F0           MOVX      @DPTR,A
    467              return ( TRUE );
   \   000041   7901         MOV       R1,#0x1
   \   000043   8002         SJMP      ??bindAddClusterIdToList_1
    468            }
    469            return ( FALSE );
   \                     ??bindAddClusterIdToList_0:
   \   000045   7900         MOV       R1,#0x0
   \                     ??bindAddClusterIdToList_1:
   \   000047                REQUIRE ?Subroutine2
   \   000047                ; // Fall through to label ?Subroutine2
    470          }
    471          
    472          /*********************************************************************
    473           * @fn      bindFindExisting
    474           *
    475           * @brief   Finds an existing src/epint to dst/epint bind record
    476           *
    477           * @param   srcEpInt - Source Endpoint/Interface
    478           * @param   dstAddr - Destination address
    479           * @param   dstEpInt - Destination Endpoint/Interface
    480           *
    481           * @return  pointer to existing entry or NULL
    482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    483          BindingEntry_t *bindFindExisting( byte srcEpInt,
   \                     bindFindExisting:
    484                                            zAddrType_t *dstAddr, byte dstEpInt )
    485          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV       A,#-0xd
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   8C..         MOV       ?V1,R4
    486            uint16 dstIdx;
    487            bindTableIndex_t x;
    488          
    489            // Find the records in the assoc list
    490            if ( dstAddr->addrMode == AddrGroup )
   \   000009   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00000C   700B         JNZ       ??bindFindExisting_0
    491            {
    492              dstIdx = dstAddr->addr.shortAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FC           MOV       R4,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FD           MOV       R5,A
   \   000017   800B         SJMP      ??bindFindExisting_1
    493            }
    494            else
    495            {
    496              dstIdx = bindingAddrMgsHelperFind( dstAddr );
   \                     ??bindFindExisting_0:
   \   000019                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000019   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   00001C   8A..         MOV       ?V2,R2
   \   00001E   8B..         MOV       ?V3,R3
   \   000020   AC..         MOV       R4,?V2
   \   000022   AD..         MOV       R5,?V3
    497            }
    498          
    499            if ( dstIdx == INVALID_NODE_ADDR )
   \                     ??bindFindExisting_1:
   \   000024   74FE         MOV       A,#-0x2
   \   000026   6C           XRL       A,R4
   \   000027   7003         JNZ       ??bindFindExisting_2
   \   000029   74FF         MOV       A,#-0x1
   \   00002B   6D           XRL       A,R5
   \                     ??bindFindExisting_2:
   \   00002C   605B         JZ        ??bindFindExisting_3
    500            {
    501              return ( (BindingEntry_t *)NULL );
    502            }
    503          
    504            // Start at the beginning
    505            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00002E   75..00       MOV       ?V2,#0x0
   \   000031   8015         SJMP      ??bindFindExisting_4
    506            {
    507              if ( (BindingTable[x].srcEP == srcEpInt) )
   \                     ??bindFindExisting_5:
   \   000033   7401         MOV       A,#0x1
   \   000035   65..         XRL       A,?V3
   \   000037   700D         JNZ       ??bindFindExisting_6
   \   000039   8882         MOV       DPL,R0
   \   00003B   8983         MOV       DPH,R1
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   6C           XRL       A,R4
   \   00003F   7003         JNZ       ??bindFindExisting_7
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   6D           XRL       A,R5
   \                     ??bindFindExisting_7:
   \   000044   6047         JZ        ??bindFindExisting_8
   \                     ??bindFindExisting_6:
   \   000046   05..         INC       ?V2
   \                     ??bindFindExisting_4:
   \   000048   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00004B   503C         JNC       ??bindFindExisting_3
   \   00004D   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000050   E0           MOVX      A,@DPTR
   \   000051   65..         XRL       A,?V0
   \   000053   70F1         JNZ       ??bindFindExisting_6
   \   000055   A3           INC       DPTR
   \   000056   E0           MOVX      A,@DPTR
   \   000057   F5..         MOV       ?V3,A
   \   000059   EA           MOV       A,R2
   \   00005A   2402         ADD       A,#0x2
   \   00005C   F8           MOV       R0,A
   \   00005D   E4           CLR       A
   \   00005E   3B           ADDC      A,R3
   \   00005F   F9           MOV       R1,A
   \   000060   8E82         MOV       DPL,R6
   \   000062   8F83         MOV       DPH,R7
   \   000064   E0           MOVX      A,@DPTR
   \   000065   6401         XRL       A,#0x1
   \   000067   60CA         JZ        ??bindFindExisting_5
   \   000069   E5..         MOV       A,?V3
   \   00006B   70D9         JNZ       ??bindFindExisting_6
   \   00006D   8882         MOV       DPL,R0
   \   00006F   8983         MOV       DPH,R1
   \   000071   E0           MOVX      A,@DPTR
   \   000072   6C           XRL       A,R4
   \   000073   7003         JNZ       ??bindFindExisting_9
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   6D           XRL       A,R5
   \                     ??bindFindExisting_9:
   \   000078   70CC         JNZ       ??bindFindExisting_6
   \   00007A   8A82         MOV       DPL,R2
   \   00007C   8B83         MOV       DPH,R3
   \   00007E   A3           INC       DPTR
   \   00007F   A3           INC       DPTR
   \   000080   A3           INC       DPTR
   \   000081   A3           INC       DPTR
   \   000082   E0           MOVX      A,@DPTR
   \   000083   65..         XRL       A,?V1
   \   000085   70BF         JNZ       ??bindFindExisting_6
    508              {
    509                if ( ((dstAddr->addrMode == AddrGroup)
    510                        && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
    511                        && (dstIdx == BindingTable[x].dstIdx))
    512                   || ((dstAddr->addrMode != AddrGroup)
    513                       && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
    514                       && (dstIdx == BindingTable[x].dstIdx) && (BindingTable[x].dstEP == dstEpInt)) )
    515                {
    516                  return ( &BindingTable[x] );
   \   000087   8004         SJMP      ??bindFindExisting_8
    517                }
    518              }
    519            }
    520          
    521            return ( (BindingEntry_t *)NULL );
   \                     ??bindFindExisting_3:
   \   000089   7A00         MOV       R2,#0x0
   \   00008B   7B00         MOV       R3,#0x0
   \                     ??bindFindExisting_8:
   \   00008D   02....       LJMP      ?Subroutine3 & 0xFFFF
    522          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   F8           MOV       R0,A
   \   000006   E5..         MOV       A,?V2
   \   000008   C3           CLR       C
   \   000009   98           SUBB      A,R0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E5..         MOV       A,?V2
   \   000002   75F00E       MOV       B,#0xe
   \   000005   A4           MUL       AB
   \   000006   F8           MOV       R0,A
   \   000007   A9F0         MOV       R1,B
   \   000009   74..         MOV       A,#BindingTable & 0xff
   \   00000B   28           ADD       A,R0
   \   00000C   FA           MOV       R2,A
   \   00000D   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   00000F   39           ADDC      A,R1
   \   000010   FB           MOV       R3,A
   \   000011   8A82         MOV       DPL,R2
   \   000013   F583         MOV       DPH,A
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   EA           MOV       A,R2
   \   000001   2408         ADD       A,#0x8
   \   000003   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000006   6401         XRL       A,#0x1
   \   000008   22           RET
    523          
    524          /*********************************************************************
    525           * @fn       bindRemoveDev()
    526           *
    527           * @brief
    528           *
    529           *   Remove all bind(s) entries associated to a device address (destination).
    530           *   Updates binding table.
    531           *
    532           * @param   Addr - address of device to be removed from Binding Table
    533           *
    534           * @return  none
    535           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    536          void bindRemoveDev( zAddrType_t *Addr )
   \                     bindRemoveDev:
    537          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    538            uint16 idx;
    539            bindTableIndex_t x;
    540          
    541            if ( Addr->addrMode == AddrGroup )
   \   000005   EA           MOV       A,R2
   \   000006   2408         ADD       A,#0x8
   \   000008   F8           MOV       R0,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   88..         MOV       ?V0,R0
   \   00000D   F5..         MOV       ?V1,A
   \   00000F   8882         MOV       DPL,R0
   \   000011   F583         MOV       DPH,A
   \   000013   E0           MOVX      A,@DPTR
   \   000014   6401         XRL       A,#0x1
   \   000016   700B         JNZ       ??bindRemoveDev_0
    542            {
    543              idx = Addr->addr.shortAddr;
   \   000018   8A82         MOV       DPL,R2
   \   00001A   8B83         MOV       DPH,R3
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   FE           MOV       R6,A
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   FF           MOV       R7,A
   \   000021   800B         SJMP      ??bindRemoveDev_1
    544            }
    545            else
    546            {
    547              idx = bindingAddrMgsHelperFind( Addr );
   \                     ??bindRemoveDev_0:
   \   000023                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000023   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   000026   8A..         MOV       ?V2,R2
   \   000028   8B..         MOV       ?V3,R3
   \   00002A   AE..         MOV       R6,?V2
   \   00002C   AF..         MOV       R7,?V3
    548            }
    549          
    550            if ( idx == INVALID_NODE_ADDR )
   \                     ??bindRemoveDev_1:
   \   00002E   74FE         MOV       A,#-0x2
   \   000030   6E           XRL       A,R6
   \   000031   7003         JNZ       ??bindRemoveDev_2
   \   000033   74FF         MOV       A,#-0x1
   \   000035   6F           XRL       A,R7
   \                     ??bindRemoveDev_2:
   \   000036   6052         JZ        ??bindRemoveDev_3
    551            {
    552              return;
    553            }
    554          
    555            // Removes all the entries that match the destination Address/Index
    556            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000038   75..00       MOV       ?V2,#0x0
   \   00003B   8015         SJMP      ??bindRemoveDev_4
    557            {
    558              if ( ( (Addr->addrMode == AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
    559                                                   && (BindingTable[x].dstIdx == idx) ) ||
    560                   ( (Addr->addrMode != AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
    561                                                   && (BindingTable[x].dstIdx == idx) ) )
   \                     ??bindRemoveDev_5:
   \   00003D   EC           MOV       A,R4
   \   00003E   7010         JNZ       ??bindRemoveDev_6
   \   000040   8882         MOV       DPL,R0
   \   000042   8983         MOV       DPH,R1
   \   000044   E0           MOVX      A,@DPTR
   \   000045   6E           XRL       A,R6
   \   000046   7003         JNZ       ??bindRemoveDev_7
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   6F           XRL       A,R7
   \                     ??bindRemoveDev_7:
   \   00004B   7003         JNZ       ??bindRemoveDev_6
    562              {
    563                bindRemoveEntry( &BindingTable[x] );
   \                     ??bindRemoveDev_8:
   \   00004D                ; Setup parameters for call to function bindRemoveEntry
   \   00004D   12....       LCALL     `??bindRemoveEntry::?relay`; Banked call to: bindRemoveEntry
    564              }
   \                     ??bindRemoveDev_6:
   \   000050   05..         INC       ?V2
   \                     ??bindRemoveDev_4:
   \   000052   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000055   502C         JNC       ??bindRemoveDev_9
   \   000057   12....       LCALL     ?Subroutine10 & 0xFFFF
    565            }
   \                     ??CrossCallReturnLabel_7:
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   FC           MOV       R4,A
   \   00005D   EA           MOV       A,R2
   \   00005E   2402         ADD       A,#0x2
   \   000060   F8           MOV       R0,A
   \   000061   E4           CLR       A
   \   000062   3B           ADDC      A,R3
   \   000063   F9           MOV       R1,A
   \   000064   85..82       MOV       DPL,?V0
   \   000067   85..83       MOV       DPH,?V1
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   6401         XRL       A,#0x1
   \   00006D   70CE         JNZ       ??bindRemoveDev_5
   \   00006F   7401         MOV       A,#0x1
   \   000071   6C           XRL       A,R4
   \   000072   70DC         JNZ       ??bindRemoveDev_6
   \   000074   8882         MOV       DPL,R0
   \   000076   8983         MOV       DPH,R1
   \   000078   E0           MOVX      A,@DPTR
   \   000079   6E           XRL       A,R6
   \   00007A   7003         JNZ       ??bindRemoveDev_10
   \   00007C   A3           INC       DPTR
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   6F           XRL       A,R7
   \                     ??bindRemoveDev_10:
   \   00007F   60CC         JZ        ??bindRemoveDev_8
   \   000081   80CD         SJMP      ??bindRemoveDev_6
    566          
    567            // If this is the last Bind Entry for that idx then clear BINDING
    568            // user from Address Manager
    569            bindAddressClear( idx );
   \                     ??bindRemoveDev_9:
   \   000083                ; Setup parameters for call to function bindAddressClear
   \   000083   EE           MOV       A,R6
   \   000084   FA           MOV       R2,A
   \   000085   EF           MOV       A,R7
   \   000086   FB           MOV       R3,A
   \   000087   12....       LCALL     `??bindAddressClear::?relay`; Banked call to: bindAddressClear
    570          }
   \                     ??bindRemoveDev_3:
   \   00008A                REQUIRE ?Subroutine4
   \   00008A                ; // Fall through to label ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    571          
    572          /*********************************************************************
    573           * @fn       bindRemoveSrcDev()
    574           *
    575           * @brief
    576           *
    577           *   Remove binds(s) associated to device address (source).
    578           *   Updates binding table.
    579           *
    580           * @param   ep - endpoint to remove, 0xFF is all endpoints
    581           *
    582           * @return  none
    583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    584          void bindRemoveSrcDev( uint8 ep )
   \                     bindRemoveSrcDev:
    585          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V1,R1
    586            bindTableIndex_t x;
    587          
    588            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000007   75..00       MOV       ?V0,#0x0
   \   00000A   8037         SJMP      ??bindRemoveSrcDev_0
    589            {
    590              if ( (ep == 0xFF) || (ep == BindingTable[x].srcEP) )
   \                     ??bindRemoveSrcDev_1:
   \   00000C   E5..         MOV       A,?V0
   \   00000E   75F00E       MOV       B,#0xe
   \   000011   A4           MUL       AB
   \   000012   F8           MOV       R0,A
   \   000013   A9F0         MOV       R1,B
   \   000015   74..         MOV       A,#BindingTable & 0xff
   \   000017   28           ADD       A,R0
   \   000018   FA           MOV       R2,A
   \   000019   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   00001B   39           ADDC      A,R1
   \   00001C   FB           MOV       R3,A
   \   00001D   74FF         MOV       A,#-0x1
   \   00001F   65..         XRL       A,?V1
   \   000021   6009         JZ        ??bindRemoveSrcDev_2
   \   000023   8A82         MOV       DPL,R2
   \   000025   8B83         MOV       DPH,R3
   \   000027   E0           MOVX      A,@DPTR
   \   000028   65..         XRL       A,?V1
   \   00002A   7015         JNZ       ??bindRemoveSrcDev_3
    591              {
    592                uint16 idx = BindingTable[x].dstIdx;
   \                     ??bindRemoveSrcDev_2:
   \   00002C   8A82         MOV       DPL,R2
   \   00002E   8B83         MOV       DPH,R3
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   FE           MOV       R6,A
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   FF           MOV       R7,A
    593          
    594                bindRemoveEntry( &BindingTable[x] );
   \   000037                ; Setup parameters for call to function bindRemoveEntry
   \   000037   12....       LCALL     `??bindRemoveEntry::?relay`; Banked call to: bindRemoveEntry
    595          
    596                // If this is the last Bind Entry for that idx then clear BINDING
    597                // user from Address Manager
    598                bindAddressClear( idx );
   \   00003A                ; Setup parameters for call to function bindAddressClear
   \   00003A   EE           MOV       A,R6
   \   00003B   FA           MOV       R2,A
   \   00003C   EF           MOV       A,R7
   \   00003D   FB           MOV       R3,A
   \   00003E   12....       LCALL     `??bindAddressClear::?relay`; Banked call to: bindAddressClear
    599              }
    600            }
   \                     ??bindRemoveSrcDev_3:
   \   000041   05..         INC       ?V0
   \                     ??bindRemoveSrcDev_0:
   \   000043   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000046   E4           CLR       A
   \   000047   93           MOVC      A,@A+DPTR
   \   000048   F8           MOV       R0,A
   \   000049   E5..         MOV       A,?V0
   \   00004B   C3           CLR       C
   \   00004C   98           SUBB      A,R0
   \   00004D   40BD         JC        ??bindRemoveSrcDev_1
    601          }
   \   00004F   02....       LJMP      ??Subroutine34_0 & 0xFFFF
    602          
    603          /*********************************************************************
    604           * @fn          bindNumBoundTo
    605           *
    606           * @brief       Calculate the number items this device is bound to.
    607           *              When srcMode is set to TRUE, discard what value devAddr
    608           *              has, it returns number count bound to the local dev.
    609           *
    610           * @param       devAddr - device Address
    611           * @param       devEP - endpoint
    612           * @param       srcMode - TRUE - assume devHandle is a source address
    613           *                        FALSE - destination address
    614           *
    615           * @return      status
    616           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    617          byte bindNumBoundTo( zAddrType_t *devAddr, byte devEpInt, byte srcMode )
   \                     bindNumBoundTo:
    618          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V1,R1
   \   000007   8C..         MOV       ?V2,R4
    619            BindingEntry_t *pBind;
    620            uint16 idx;
    621            byte   num;
    622            bindTableIndex_t x;
    623          
    624            // Init
    625            num = 0;
   \   000009   75..00       MOV       ?V0,#0x0
    626          
    627            if ( devAddr->addrMode == AddrGroup )
   \   00000C   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00000F   7009         JNZ       ??bindNumBoundTo_0
    628            {
    629              idx = devAddr->addr.shortAddr;
   \   000011   8A82         MOV       DPL,R2
   \   000013   8B83         MOV       DPH,R3
   \   000015   12....       LCALL     ??Subroutine46_0 & 0xFFFF
    630            }
   \                     ??CrossCallReturnLabel_64:
   \   000018   8003         SJMP      ??bindNumBoundTo_1
    631            else
    632            {
    633              idx = bindingAddrMgsHelperFind( devAddr );
   \                     ??bindNumBoundTo_0:
   \   00001A                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   00001A   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
    634            }
    635          
    636            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \                     ??bindNumBoundTo_1:
   \   00001D   7C00         MOV       R4,#0x0
   \   00001F   8022         SJMP      ??bindNumBoundTo_2
    637            {
    638              pBind = &BindingTable[x];
    639              if ( srcMode )
    640              {
    641                if ( pBind->srcEP == devEpInt )
    642                {
    643                  num++;
    644                }
    645              }
    646              else
    647              {
    648                if ( ((devAddr->addrMode == AddrGroup)
    649                        && (pBind->dstGroupMode == DSTGROUPMODE_GROUP) && (pBind->dstIdx == idx))
    650                    || ((devAddr->addrMode != AddrGroup) && (pBind->dstGroupMode == DSTGROUPMODE_ADDR)
    651                                          && (pBind->dstIdx == idx) && (pBind->dstEP == devEpInt)) )
   \                     ??bindNumBoundTo_3:
   \   000021   ED           MOV       A,R5
   \   000022   701E         JNZ       ??bindNumBoundTo_4
   \   000024   8882         MOV       DPL,R0
   \   000026   8983         MOV       DPH,R1
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   6A           XRL       A,R2
   \   00002C   7003         JNZ       ??bindNumBoundTo_5
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   6B           XRL       A,R3
   \                     ??bindNumBoundTo_5:
   \   000031   700F         JNZ       ??bindNumBoundTo_4
   \   000033   8882         MOV       DPL,R0
   \   000035   8983         MOV       DPH,R1
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   65..         XRL       A,?V1
   \   00003E   7002         JNZ       ??bindNumBoundTo_4
    652                {
    653                  num++;
   \                     ??bindNumBoundTo_6:
   \   000040   05..         INC       ?V0
    654                }
   \                     ??bindNumBoundTo_4:
   \   000042   0C           INC       R4
   \                     ??bindNumBoundTo_2:
   \   000043   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000046   E4           CLR       A
   \   000047   93           MOVC      A,@A+DPTR
   \   000048   F8           MOV       R0,A
   \   000049   EC           MOV       A,R4
   \   00004A   C3           CLR       C
   \   00004B   98           SUBB      A,R0
   \   00004C   5034         JNC       ??bindNumBoundTo_7
   \   00004E   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000051   E5..         MOV       A,?V2
   \   000053   8882         MOV       DPL,R0
   \   000055   8983         MOV       DPH,R1
   \   000057   6007         JZ        ??bindNumBoundTo_8
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   65..         XRL       A,?V1
   \   00005C   70E4         JNZ       ??bindNumBoundTo_4
   \   00005E   80E0         SJMP      ??bindNumBoundTo_6
   \                     ??bindNumBoundTo_8:
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   FD           MOV       R5,A
   \   000063   8E82         MOV       DPL,R6
   \   000065   8F83         MOV       DPH,R7
   \   000067   E0           MOVX      A,@DPTR
   \   000068   6401         XRL       A,#0x1
   \   00006A   70B5         JNZ       ??bindNumBoundTo_3
   \   00006C   7401         MOV       A,#0x1
   \   00006E   6D           XRL       A,R5
   \   00006F   70D1         JNZ       ??bindNumBoundTo_4
   \   000071   8882         MOV       DPL,R0
   \   000073   8983         MOV       DPH,R1
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   E0           MOVX      A,@DPTR
   \   000078   6A           XRL       A,R2
   \   000079   7003         JNZ       ??bindNumBoundTo_9
   \   00007B   A3           INC       DPTR
   \   00007C   E0           MOVX      A,@DPTR
   \   00007D   6B           XRL       A,R3
   \                     ??bindNumBoundTo_9:
   \   00007E   60C0         JZ        ??bindNumBoundTo_6
   \   000080   80C0         SJMP      ??bindNumBoundTo_4
    655              }
    656            }
    657          
    658            return num;
   \                     ??bindNumBoundTo_7:
   \   000082   A9..         MOV       R1,?V0
   \   000084   02....       LJMP      ??Subroutine45_0 & 0xFFFF
    659          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   EC           MOV       A,R4
   \   000001                REQUIRE ??Subroutine36_0
   \   000001                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   75F00E       MOV       B,#0xe
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007   74..         MOV       A,#BindingTable & 0xff
   \   000009   28           ADD       A,R0
   \   00000A   F8           MOV       R0,A
   \   00000B   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   00000D   39           ADDC      A,R1
   \   00000E   F9           MOV       R1,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET
    660          
    661          /*********************************************************************
    662           * @fn          bindNumReflections
    663           *
    664           * @brief       Counts the number of reflections needed for a
    665           *              endpoint and cluster ID combo.
    666           *
    667           * @param       ep - source endpoint
    668           * @param       clusterID - matching clusterID
    669           *
    670           * @return      number of reflections needed.
    671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    672          uint16 bindNumReflections( uint8 ep, uint16 clusterID )
   \                     bindNumReflections:
    673          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V3,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
    674            bindTableIndex_t x;
    675            BindingEntry_t *pBind;
    676            uint16 cnt = 0;
   \   00000B   7E00         MOV       R6,#0x0
   \   00000D   7F00         MOV       R7,#0x0
    677            uint8 bindEP;
    678          
    679            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00000F   75..00       MOV       ?V2,#0x0
   \   000012   8025         SJMP      ??bindNumReflections_0
    680            {
    681              pBind = &BindingTable[x];
   \                     ??bindNumReflections_1:
   \   000014   E5..         MOV       A,?V2
   \   000016   75F00E       MOV       B,#0xe
   \   000019   A4           MUL       AB
   \   00001A   F8           MOV       R0,A
   \   00001B   A9F0         MOV       R1,B
   \   00001D   12....       LCALL     ?Subroutine29 & 0xFFFF
    682              bindEP = pBind->srcEP;
    683          
    684              if ( (bindEP == ep) && (bindIsClusterIDinList( pBind, clusterID )) )
   \                     ??CrossCallReturnLabel_45:
   \   000020   65..         XRL       A,?V3
   \   000022   7013         JNZ       ??bindNumReflections_2
   \   000024                ; Setup parameters for call to function bindIsClusterIDinList
   \   000024   AC..         MOV       R4,?V0
   \   000026   AD..         MOV       R5,?V1
   \   000028   AA82         MOV       R2,DPL
   \   00002A   AB83         MOV       R3,DPH
   \   00002C   12....       LCALL     `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   00002F   E9           MOV       A,R1
   \   000030   6005         JZ        ??bindNumReflections_2
    685              {
    686                cnt++;
   \   000032   0E           INC       R6
   \   000033   EE           MOV       A,R6
   \   000034   7001         JNZ       ??bindNumReflections_2
   \   000036   0F           INC       R7
    687              }
    688            }
   \                     ??bindNumReflections_2:
   \   000037   05..         INC       ?V2
   \                     ??bindNumReflections_0:
   \   000039   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   00003C   40D6         JC        ??bindNumReflections_1
    689          
    690            return ( cnt );
   \   00003E   EE           MOV       A,R6
   \   00003F   FA           MOV       R2,A
   \   000040   EF           MOV       A,R7
   \   000041   FB           MOV       R3,A
   \   000042   02....       LJMP      ?Subroutine4 & 0xFFFF
    691          }
    692          
    693          /*********************************************************************
    694           * @fn          bindFind
    695           *
    696           * @brief       Finds the binding entry for the source address, endpoint
    697           *              and cluster ID passed in as a parameter.
    698           *
    699           * @param       ep - source endpoint
    700           * @param       clusterID - matching clusterID
    701           * @param       skip - number of matches to skip before returning
    702           *
    703           * @return      pointer to the binding table entry, NULL if not found
    704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    705          BindingEntry_t *bindFind( uint8 ep, uint16 clusterID, uint8 skipping )
   \                     bindFind:
    706          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   8C..         MOV       ?V5,R4
    707            BindingEntry_t *pBind;
    708            byte skipped = 0;
   \   00000D   75..00       MOV       ?V2,#0x0
    709            bindTableIndex_t x;
    710          
    711            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000010   75..00       MOV       ?V3,#0x0
   \   000013   8004         SJMP      ??bindFind_0
    712            {
    713              pBind = &BindingTable[x];
    714          
    715              if ( ( pBind->srcEP == ep) && bindIsClusterIDinList( pBind, clusterID ))
    716              {
    717                if ( skipped < skipping )
    718                {
    719                  skipped++;
   \                     ??bindFind_1:
   \   000015   05..         INC       ?V2
    720                }
   \                     ??bindFind_2:
   \   000017   05..         INC       ?V3
   \                     ??bindFind_0:
   \   000019   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00001C   E4           CLR       A
   \   00001D   93           MOVC      A,@A+DPTR
   \   00001E   F8           MOV       R0,A
   \   00001F   E5..         MOV       A,?V3
   \   000021   C3           CLR       C
   \   000022   98           SUBB      A,R0
   \   000023   5024         JNC       ??bindFind_3
   \   000025   E5..         MOV       A,?V3
   \   000027   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00002A   65..         XRL       A,?V4
   \   00002C   70E9         JNZ       ??bindFind_2
   \   00002E                ; Setup parameters for call to function bindIsClusterIDinList
   \   00002E   AC..         MOV       R4,?V0
   \   000030   AD..         MOV       R5,?V1
   \   000032   EE           MOV       A,R6
   \   000033   FA           MOV       R2,A
   \   000034   EF           MOV       A,R7
   \   000035   FB           MOV       R3,A
   \   000036   12....       LCALL     `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   000039   E9           MOV       A,R1
   \   00003A   60DB         JZ        ??bindFind_2
   \   00003C   E5..         MOV       A,?V2
   \   00003E   C3           CLR       C
   \   00003F   95..         SUBB      A,?V5
   \   000041   40D2         JC        ??bindFind_1
    721                else
    722                {
    723                  return ( pBind );
   \   000043   EE           MOV       A,R6
   \   000044   FA           MOV       R2,A
   \   000045   EF           MOV       A,R7
   \   000046   FB           MOV       R3,A
   \   000047   8004         SJMP      ??bindFind_4
    724                }
    725              }
    726            }
    727          
    728            return ( (BindingEntry_t *)NULL );
   \                     ??bindFind_3:
   \   000049   7A00         MOV       R2,#0x0
   \   00004B   7B00         MOV       R3,#0x0
   \                     ??bindFind_4:
   \   00004D   02....       LJMP      ??Subroutine45_0 & 0xFFFF
    729          }
    730          
    731          /*********************************************************************
    732           * @fn      bindAddressClear
    733           *
    734           * @brief   Lookup a binding entry by specific Idx, if none is found
    735           *          clears the BINDING user from Address Manager.
    736           *
    737           * @param   dstIdx - Source Address Manager Index
    738           *
    739           * @return  none
    740           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    741          void bindAddressClear( uint16 dstIdx )
   \                     bindAddressClear:
    742          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    743            bindTableIndex_t i;
    744          
    745            if ( dstIdx != INVALID_NODE_ADDR )
   \   000009   74FE         MOV       A,#-0x2
   \   00000B   6A           XRL       A,R2
   \   00000C   7003         JNZ       ??bindAddressClear_0
   \   00000E   74FF         MOV       A,#-0x1
   \   000010   6B           XRL       A,R3
   \                     ??bindAddressClear_0:
   \   000011   604A         JZ        ??bindAddressClear_1
    746            {
    747              // Looks for a specific Idx
    748              for ( i = 0; i < gNWK_MAX_BINDING_ENTRIES; i++ )
   \   000013   7C00         MOV       R4,#0x0
   \   000015   8022         SJMP      ??bindAddressClear_2
    749              {
    750                if ( ( BindingTable[i].dstGroupMode != AddrGroup ) &&
    751                     ( BindingTable[i].dstGroupMode == DSTGROUPMODE_ADDR ) &&
    752                     ( BindingTable[i].dstIdx == dstIdx ) )
   \                     ??bindAddressClear_3:
   \   000017   12....       LCALL     ?Subroutine13 & 0xFFFF
    753                {
    754                  break;  // found at least one
    755                }
    756              }
   \                     ??CrossCallReturnLabel_49:
   \   00001A   8882         MOV       DPL,R0
   \   00001C   F583         MOV       DPH,A
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   FD           MOV       R5,A
   \   000021   7401         MOV       A,#0x1
   \   000023   6D           XRL       A,R5
   \   000024   6012         JZ        ??bindAddressClear_4
   \   000026   ED           MOV       A,R5
   \   000027   700F         JNZ       ??bindAddressClear_4
   \   000029   8882         MOV       DPL,R0
   \   00002B   8983         MOV       DPH,R1
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   6A           XRL       A,R2
   \   000031   7003         JNZ       ??bindAddressClear_5
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   6B           XRL       A,R3
   \                     ??bindAddressClear_5:
   \   000036   6025         JZ        ??bindAddressClear_1
   \                     ??bindAddressClear_4:
   \   000038   0C           INC       R4
   \                     ??bindAddressClear_2:
   \   000039   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00003C   E4           CLR       A
   \   00003D   93           MOVC      A,@A+DPTR
   \   00003E   F8           MOV       R0,A
   \   00003F   EC           MOV       A,R4
   \   000040   C3           CLR       C
   \   000041   98           SUBB      A,R0
   \   000042   40D3         JC        ??bindAddressClear_3
    757          
    758              if ( i == gNWK_MAX_BINDING_ENTRIES )
   \   000044   E4           CLR       A
   \   000045   93           MOVC      A,@A+DPTR
   \   000046   6C           XRL       A,R4
   \   000047   7014         JNZ       ??bindAddressClear_1
    759              {
    760                // No binding entry is associated with dstIdx.
    761                // Remove user binding bit from the address manager entry corresponding to dstIdx.
    762                AddrMgrEntry_t addrEntry;
    763          
    764                addrEntry.user = ADDRMGR_USER_BINDING;
   \   000049   85..82       MOV       DPL,?XSP + 0
   \   00004C   85..83       MOV       DPH,?XSP + 1
   \   00004F   7404         MOV       A,#0x4
   \   000051   F0           MOVX      @DPTR,A
    765                addrEntry.index = dstIdx;
   \   000052   740B         MOV       A,#0xb
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   12....       LCALL     ?Subroutine31 & 0xFFFF
    766          
    767                AddrMgrEntryRelease( &addrEntry );
    768              }
    769            }
   \                     ??CrossCallReturnLabel_50:
   \   00005A   12....       LCALL     `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
    770          }
   \                     ??bindAddressClear_1:
   \   00005D   80..         SJMP      ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004                REQUIRE ??Subroutine37_0
   \   000004                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000001                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   740D         MOV       A,#0xd
   \   000002   12....       LCALL     ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine40_0
   \   000005                ; // Fall through to label ??Subroutine40_0
    771          
    772          /*********************************************************************
    773           * @fn          bindUpdateAddr
    774           *
    775           * @brief       Update the network address in the binding table.
    776           *
    777           * @param       oldAddr - old network address
    778           * @param       newAddr - new network address
    779           *
    780           * @return      none
    781           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    782          void bindUpdateAddr( uint16 oldAddr, uint16 newAddr )
   \                     bindUpdateAddr:
    783          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    784            uint16 oldIdx;
    785            uint16 newIdx;
    786            zAddrType_t addr;
    787            bindTableIndex_t x;
    788            BindingEntry_t *pBind;
    789          
    790            addr.addrMode = Addr16Bit;
   \   00000E   7408         MOV       A,#0x8
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   7402         MOV       A,#0x2
   \   000015   F0           MOVX      @DPTR,A
    791            addr.addr.shortAddr = oldAddr;
   \   000016   85..82       MOV       DPL,?XSP + 0
   \   000019   85..83       MOV       DPH,?XSP + 1
   \   00001C   EA           MOV       A,R2
   \   00001D   F0           MOVX      @DPTR,A
   \   00001E   A3           INC       DPTR
   \   00001F   EB           MOV       A,R3
   \   000020   12....       LCALL     ?Subroutine17 & 0xFFFF
    792            oldIdx = bindingAddrMgsHelperFind( &addr );
   \                     ??CrossCallReturnLabel_20:
   \   000023   8A..         MOV       ?V0,R2
   \   000025   8B..         MOV       ?V1,R3
    793            addr.addr.shortAddr = newAddr;
   \   000027   85..82       MOV       DPL,?XSP + 0
   \   00002A   85..83       MOV       DPH,?XSP + 1
   \   00002D   EE           MOV       A,R6
   \   00002E   F0           MOVX      @DPTR,A
   \   00002F   A3           INC       DPTR
   \   000030   EF           MOV       A,R7
   \   000031   12....       LCALL     ?Subroutine17 & 0xFFFF
    794            newIdx = bindingAddrMgsHelperFind( &addr );
   \                     ??CrossCallReturnLabel_21:
   \   000034   8A..         MOV       ?V2,R2
    795          
    796            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000036   7A00         MOV       R2,#0x0
   \   000038   8025         SJMP      ??bindUpdateAddr_0
    797            {
    798              pBind = &BindingTable[x];
   \                     ??bindUpdateAddr_1:
   \   00003A   EA           MOV       A,R2
   \   00003B   12....       LCALL     ??Subroutine36_0 & 0xFFFF
    799          
    800              if ( pBind->dstIdx == oldIdx )
   \                     ??CrossCallReturnLabel_47:
   \   00003E   E8           MOV       A,R0
   \   00003F   2402         ADD       A,#0x2
   \   000041   F8           MOV       R0,A
   \   000042   5001         JNC       ??bindUpdateAddr_2
   \   000044   09           INC       R1
   \                     ??bindUpdateAddr_2:
   \   000045   F582         MOV       DPL,A
   \   000047   8983         MOV       DPH,R1
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   65..         XRL       A,?V0
   \   00004C   7004         JNZ       ??bindUpdateAddr_3
   \   00004E   A3           INC       DPTR
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   65..         XRL       A,?V1
   \                     ??bindUpdateAddr_3:
   \   000052   700A         JNZ       ??bindUpdateAddr_4
    801              {
    802                pBind->dstIdx = newIdx;
   \   000054   8882         MOV       DPL,R0
   \   000056   8983         MOV       DPH,R1
   \   000058   E5..         MOV       A,?V2
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   EB           MOV       A,R3
   \   00005D   F0           MOVX      @DPTR,A
    803              }
    804            }
   \                     ??bindUpdateAddr_4:
   \   00005E   0A           INC       R2
   \                     ??bindUpdateAddr_0:
   \   00005F   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000062   E4           CLR       A
   \   000063   93           MOVC      A,@A+DPTR
   \   000064   F8           MOV       R0,A
   \   000065   EA           MOV       A,R2
   \   000066   C3           CLR       C
   \   000067   98           SUBB      A,R0
   \   000068   40D0         JC        ??bindUpdateAddr_1
    805          }
   \   00006A   7409         MOV       A,#0x9
   \   00006C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006F   02....       LJMP      ?Subroutine4 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL     ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000003   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   000006   22           RET
    806          
    807          /*********************************************************************
    808           * @fn      bindingAddrMgsHelperFind
    809           *
    810           * @brief   Turns an zAddrType_t to an Addr Manager index
    811           *
    812           * @param   addr - zAddrType_t
    813           *
    814           * @return  INVALID_NODE_ADDR if not found, otherwise an index
    815           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   740B         MOV       A,#0xb
   \   000002                REQUIRE ??Subroutine38_0
   \   000002                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   12....       LCALL     ?XSTACK_DISP0_8
   \   000003   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000006                REQUIRE ??Subroutine39_0
   \   000006                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    816          uint16 bindingAddrMgsHelperFind( zAddrType_t *addr )
   \                     bindingAddrMgsHelperFind:
    817          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    818            AddrMgrEntry_t entry;
    819          
    820            // Resolve addresses with the address manager
    821            entry.user = ADDRMGR_USER_BINDING;
   \   000009   12....       LCALL     ?Subroutine14 & 0xFFFF
    822            if ( addr->addrMode == Addr16Bit )
   \                     ??CrossCallReturnLabel_14:
   \   00000C   6402         XRL       A,#0x2
   \   00000E   700B         JNZ       ??bindingAddrMgsHelperFind_0
    823            {
    824              entry.nwkAddr = addr->addr.shortAddr;
   \   000010   12....       LCALL     ?Subroutine19 & 0xFFFF
    825              AddrMgrEntryLookupNwk( &entry );
    826            }
   \                     ??CrossCallReturnLabel_55:
   \   000013   12....       LCALL     ?XSTACK_DISP0_8
   \   000016   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000019   800C         SJMP      ??CrossCallReturnLabel_34
    827            else
    828            {
    829              AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
   \                     ??bindingAddrMgsHelperFind_0:
   \   00001B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001B   EA           MOV       A,R2
   \   00001C   FC           MOV       R4,A
   \   00001D   EB           MOV       A,R3
   \   00001E   FD           MOV       R5,A
   \   00001F   7403         MOV       A,#0x3
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ?Subroutine25 & 0xFFFF
    830              AddrMgrEntryLookupExt( &entry );
    831            }
    832          
    833            return ( entry.index );
   \                     ??CrossCallReturnLabel_34:
   \   000027   02....       LJMP      ?Subroutine1 & 0xFFFF
    834          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004                REQUIRE ??Subroutine41_0
   \   000004                ; // Fall through to label ??Subroutine41_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   7401         MOV       A,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   AA82         MOV       R2,DPL
   \   000002   AB83         MOV       R3,DPH
   \   000004   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000007                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000007                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000007   AA..         MOV       R2,?XSP + 0
   \   000009   AB..         MOV       R3,?XSP + 1
   \   00000B   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   12....       LCALL     ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000007   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   7404         MOV       A,#0x4
   \   000008   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   22           RET
    835          
    836          /*********************************************************************
    837           * @fn      bindingAddrMgsHelperConvert
    838           *
    839           * @brief   Convert an index into an zAddrType_t
    840           *
    841           * @param   idx -
    842           * @param   addr - zAddrType_t
    843           *
    844           * @return  TRUE if found, FALSE if not
    845           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    846          uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr )
   \                     bindingAddrMgsHelperConvert:
    847          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    848            AddrMgrEntry_t entry;
    849            uint8 stat;
    850          
    851            // Resolve addresses with the address manager
    852            entry.user = ADDRMGR_USER_BINDING;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7404         MOV       A,#0x4
   \   000016   F0           MOVX      @DPTR,A
    853            entry.index = idx;
   \   000017   740B         MOV       A,#0xb
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ?Subroutine15 & 0xFFFF
    854            stat = AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_16:
   \   00001F   E9           MOV       A,R1
   \   000020   F5..         MOV       ?V0,A
    855            if ( stat )
   \   000022   601D         JZ        ??bindingAddrMgsHelperConvert_0
    856            {
    857              addr->addrMode = Addr64Bit;
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   7403         MOV       A,#0x3
   \   000032   F0           MOVX      @DPTR,A
    858              osal_cpyExtAddr( addr->addr.extAddr, entry.extAddr );
   \   000033                ; Setup parameters for call to function sAddrExtCpy
   \   000033   12....       LCALL     ?XSTACK_DISP0_8
   \   000036   AC82         MOV       R4,DPL
   \   000038   AD83         MOV       R5,DPH
   \   00003A   EE           MOV       A,R6
   \   00003B   FA           MOV       R2,A
   \   00003C   EF           MOV       A,R7
   \   00003D   FB           MOV       R3,A
   \   00003E   12....       LCALL     `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
    859            }
    860          
    861            return ( stat );
   \                     ??bindingAddrMgsHelperConvert_0:
   \   000041   A9..         MOV       R1,?V0
   \   000043   740D         MOV       A,#0xd
   \   000045   12....       LCALL     ?DEALLOC_XSTACK8
   \   000048   02....       LJMP      ?Subroutine2 & 0xFFFF
    862          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000003   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   \   000006   22           RET
    863          
    864          /*********************************************************************
    865           * @fn      bindingAddrMgsHelperConvertShort
    866           *
    867           * @brief   Convert an index into a short address
    868           *
    869           * @param   idx -
    870           *
    871           * @return  INVALID_NODE_ADDR if not available, otherwise the short address
    872           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          uint16 bindingAddrMgsHelperConvertShort( uint16 idx )
   \                     bindingAddrMgsHelperConvertShort:
    874          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    875            AddrMgrEntry_t entry;
    876          
    877            // Resolve addresses with the address manager
    878            entry.user = ADDRMGR_USER_BINDING;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   7404         MOV       A,#0x4
   \   000011   F0           MOVX      @DPTR,A
    879            entry.index = idx;
   \   000012   740B         MOV       A,#0xb
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine15 & 0xFFFF
    880            AddrMgrEntryGet( &entry );
    881          
    882            return ( entry.nwkAddr );
   \                     ??CrossCallReturnLabel_17:
   \   00001A   7401         MOV       A,#0x1
   \   00001C   02....       LJMP      ??Subroutine38_0 & 0xFFFF
    883          }
    884          
    885          /*********************************************************************
    886           * @fn      bindAddrMgrLocalLoad
    887           *
    888           * @brief   Load local(self and parent) address information into
    889           *          Address Manager
    890           *
    891           * @param   none
    892           *
    893           * @return  none
    894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine34_0
   \   000003                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    895          void bindAddrMgrLocalLoad( void )
   \                     bindAddrMgrLocalLoad:
    896          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    897            AddrMgrEntry_t entry;
    898            uint16         parent;
    899          
    900            // add "local"(self and parent) address informtion into the Address
    901            // Manager
    902            if ( bindAddrMgrLocalLoaded == FALSE )
   \   00000A   90....       MOV       DPTR,#bindAddrMgrLocalLoaded
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   707B         JNZ       ??bindAddrMgrLocalLoad_0
    903            {
    904              // add the device's address information
    905              entry.user    = ADDRMGR_USER_BINDING;
   \   000010   85..82       MOV       DPL,?XSP + 0
   \   000013   85..83       MOV       DPH,?XSP + 1
   \   000016   7404         MOV       A,#0x4
   \   000018   F0           MOVX      @DPTR,A
    906              entry.nwkAddr = _NIB.nwkDevAddress;
   \   000019   90....       MOV       DPTR,#_NIB + 20
   \   00001C   12....       LCALL     ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   E8           MOV       A,R0
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   E9           MOV       A,R1
   \   000026   F0           MOVX      @DPTR,A
    907              AddrMgrExtAddrSet( entry.extAddr, NLME_GetExtAddr() );
   \   000027                ; Setup parameters for call to function NLME_GetExtAddr
   \   000027   12....       LCALL     `??NLME_GetExtAddr::?relay`; Banked call to: NLME_GetExtAddr
   \   00002A   8A..         MOV       ?V0,R2
   \   00002C   8B..         MOV       ?V1,R3
   \   00002E   AC..         MOV       R4,?V0
   \   000030   AD..         MOV       R5,?V1
   \   000032                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000032   7403         MOV       A,#0x3
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   AA82         MOV       R2,DPL
   \   000039   AB83         MOV       R3,DPH
   \   00003B   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    908              AddrMgrEntryUpdate( &entry );
   \   00003E                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003E   AA..         MOV       R2,?XSP + 0
   \   000040   AB..         MOV       R3,?XSP + 1
   \   000042   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
    909          
    910              // make sure parent address is valid
    911              parent = NLME_GetCoordShortAddr();
   \   000045                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000045   12....       LCALL     `??NLME_GetCoordShortAddr::?relay`; Banked call to: NLME_GetCoordShortAddr
   \   000048   8A..         MOV       ?V0,R2
   \   00004A   8B..         MOV       ?V1,R3
   \   00004C   A8..         MOV       R0,?V0
   \   00004E   A9..         MOV       R1,?V1
    912              if ( ( parent != entry.nwkAddr     ) &&
    913                   ( parent != INVALID_NODE_ADDR )    )
   \   000050   7401         MOV       A,#0x1
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   E0           MOVX      A,@DPTR
   \   000056   68           XRL       A,R0
   \   000057   7003         JNZ       ??bindAddrMgrLocalLoad_1
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   69           XRL       A,R1
   \                     ??bindAddrMgrLocalLoad_1:
   \   00005C   6027         JZ        ??bindAddrMgrLocalLoad_2
   \   00005E   74FE         MOV       A,#-0x2
   \   000060   68           XRL       A,R0
   \   000061   7003         JNZ       ??bindAddrMgrLocalLoad_3
   \   000063   74FF         MOV       A,#-0x1
   \   000065   69           XRL       A,R1
   \                     ??bindAddrMgrLocalLoad_3:
   \   000066   601D         JZ        ??bindAddrMgrLocalLoad_2
    914              {
    915                // add the parent's address information
    916                entry.nwkAddr = parent;
   \   000068   7401         MOV       A,#0x1
   \   00006A   12....       LCALL     ?XSTACK_DISP0_8
   \   00006D   EA           MOV       A,R2
   \   00006E   F0           MOVX      @DPTR,A
   \   00006F   A3           INC       DPTR
   \   000070   EB           MOV       A,R3
   \   000071   F0           MOVX      @DPTR,A
    917                NLME_GetCoordExtAddr( entry.extAddr );
   \   000072                ; Setup parameters for call to function NLME_GetCoordExtAddr
   \   000072   7403         MOV       A,#0x3
   \   000074   12....       LCALL     ?XSTACK_DISP0_8
   \   000077   AA82         MOV       R2,DPL
   \   000079   AB83         MOV       R3,DPH
   \   00007B   12....       LCALL     `??NLME_GetCoordExtAddr::?relay`; Banked call to: NLME_GetCoordExtAddr
    918                AddrMgrEntryUpdate( &entry );
   \   00007E                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00007E   AA..         MOV       R2,?XSP + 0
   \   000080   AB..         MOV       R3,?XSP + 1
   \   000082   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
    919              }
    920          
    921              bindAddrMgrLocalLoaded = TRUE;
   \                     ??bindAddrMgrLocalLoad_2:
   \   000085   90....       MOV       DPTR,#bindAddrMgrLocalLoaded
   \   000088   7401         MOV       A,#0x1
   \   00008A   F0           MOVX      @DPTR,A
    922            }
    923          }
   \                     ??bindAddrMgrLocalLoad_0:
   \   00008B   740D         MOV       A,#0xd
   \   00008D   02....       LJMP      ?Subroutine0 & 0xFFFF
    924          
    925          /*********************************************************************
    926           * @fn      bindAddrIndexGet
    927           *
    928           * @brief   Get bind address index.
    929           *
    930           * @param   addr - <zAddrType_t>
    931           *
    932           * @return  (uint16) address index
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          uint16 bindAddrIndexGet( zAddrType_t* addr )
   \                     bindAddrIndexGet:
    935          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    936            AddrMgrEntry_t entry;
    937            uint8          update;
    938          
    939            update = FALSE;
    940          
    941            // sync binding addresses with the address manager
    942            entry.user = ADDRMGR_USER_BINDING;
   \   000009   12....       LCALL     ?Subroutine14 & 0xFFFF
    943          
    944            if ( addr->addrMode == Addr16Bit )
   \                     ??CrossCallReturnLabel_15:
   \   00000C   F8           MOV       R0,A
   \   00000D   7402         MOV       A,#0x2
   \   00000F   68           XRL       A,R0
   \   000010   700E         JNZ       ??bindAddrIndexGet_0
    945            {
    946              entry.nwkAddr = addr->addr.shortAddr;
   \   000012   12....       LCALL     ?Subroutine19 & 0xFFFF
    947          
    948              if ( AddrMgrEntryLookupNwk( &entry ) == FALSE )
    949              {
    950                update = TRUE;
    951              }
    952            }
   \                     ??CrossCallReturnLabel_56:
   \   000015   12....       LCALL     ?XSTACK_DISP0_8
   \   000018   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00001B   E9           MOV       A,R1
   \   00001C   7041         JNZ       ??bindAddrIndexGet_1
   \   00001E   8014         SJMP      ??bindAddrIndexGet_2
    953            else if ( addr->addrMode == Addr64Bit )
   \                     ??bindAddrIndexGet_0:
   \   000020   7403         MOV       A,#0x3
   \   000022   68           XRL       A,R0
   \   000023   7018         JNZ       ??bindAddrIndexGet_3
    954            {
    955              AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000025   EA           MOV       A,R2
   \   000026   FC           MOV       R4,A
   \   000027   EB           MOV       A,R3
   \   000028   FD           MOV       R5,A
   \   000029   7403         MOV       A,#0x3
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   12....       LCALL     ?Subroutine25 & 0xFFFF
    956          
    957              if ( AddrMgrEntryLookupExt( &entry ) == FALSE )
   \                     ??CrossCallReturnLabel_35:
   \   000031   E9           MOV       A,R1
   \   000032   702B         JNZ       ??bindAddrIndexGet_1
    958              {
    959                update = TRUE;
    960              }
    961            }
    962            else if ( addr->addrMode == AddrGroup )
    963            {
    964              entry.index = addr->addr.shortAddr;
    965            }
    966            else
    967            {
    968              entry.index = INVALID_NODE_ADDR;
    969            }
    970          
    971            if ( update )
    972            {
    973              AddrMgrEntryUpdate( &entry );
   \                     ??bindAddrIndexGet_2:
   \   000034                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000034   AA..         MOV       R2,?XSP + 0
   \   000036   AB..         MOV       R3,?XSP + 1
   \   000038   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00003B   8022         SJMP      ??bindAddrIndexGet_1
    974            }
   \                     ??bindAddrIndexGet_3:
   \   00003D   7401         MOV       A,#0x1
   \   00003F   68           XRL       A,R0
   \   000040   7012         JNZ       ??bindAddrIndexGet_4
   \   000042   8A82         MOV       DPL,R2
   \   000044   8B83         MOV       DPH,R3
   \   000046   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000049   740B         MOV       A,#0xb
   \   00004B   12....       LCALL     ?XSTACK_DISP0_8
   \   00004E   E8           MOV       A,R0
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   A3           INC       DPTR
   \   000051   E9           MOV       A,R1
   \   000052   800A         SJMP      ??bindAddrIndexGet_5
   \                     ??bindAddrIndexGet_4:
   \   000054   740B         MOV       A,#0xb
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   74FE         MOV       A,#-0x2
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   A3           INC       DPTR
   \   00005D   04           INC       A
   \                     ??bindAddrIndexGet_5:
   \   00005E   F0           MOVX      @DPTR,A
    975          
    976            return entry.index;
   \                     ??bindAddrIndexGet_1:
   \   00005F   02....       LJMP      ?Subroutine1 & 0xFFFF
    977          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET
    978          
    979          /*********************************************************************
    980           * @fn      GetBindingTableEntry
    981           *
    982           * @brief   Get a pointer to the Nth valid binding table entry.
    983           *
    984           * @param   Nth valid entry being requested.
    985           *
    986           * @return  The Nth valid binding table entry.
    987           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    988          BindingEntry_t *GetBindingTableEntry( uint16 Nth )
   \                     GetBindingTableEntry:
    989          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    990            BindingEntry_t *rtrn = NULL;
   \   000005   7800         MOV       R0,#0x0
   \   000007   7900         MOV       R1,#0x0
    991          
    992          #if defined ( REFLECTOR )
    993            bindTableIndex_t idx, cnt = 0;
   \   000009   7C00         MOV       R4,#0x0
    994          
    995            for ( idx = 0; idx < gNWK_MAX_BINDING_ENTRIES; idx++ )
   \   00000B   7D00         MOV       R5,#0x0
   \   00000D   8001         SJMP      ??GetBindingTableEntry_0
   \                     ??GetBindingTableEntry_1:
   \   00000F   0D           INC       R5
   \                     ??GetBindingTableEntry_0:
   \   000010   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000013   E4           CLR       A
   \   000014   93           MOVC      A,@A+DPTR
   \   000015   FE           MOV       R6,A
   \   000016   ED           MOV       A,R5
   \   000017   C3           CLR       C
   \   000018   9E           SUBB      A,R6
   \   000019   502A         JNC       ??GetBindingTableEntry_2
    996            {
    997              if ( BindingTable[idx].srcEP != NV_BIND_EMPTY )
   \   00001B   ED           MOV       A,R5
   \   00001C   75F00E       MOV       B,#0xe
   \   00001F   A4           MUL       AB
   \   000020   FE           MOV       R6,A
   \   000021   85F0..       MOV       ?V0,B
   \   000024   AF..         MOV       R7,?V0
   \   000026   74..         MOV       A,#BindingTable & 0xff
   \   000028   2E           ADD       A,R6
   \   000029   F582         MOV       DPL,A
   \   00002B   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   00002D   3F           ADDC      A,R7
   \   00002E   F583         MOV       DPH,A
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F4           CPL       A
   \   000032   60DB         JZ        ??GetBindingTableEntry_1
    998              {
    999                if ( cnt++ == Nth )
   \   000034   8C..         MOV       ?V0,R4
   \   000036   7401         MOV       A,#0x1
   \   000038   2C           ADD       A,R4
   \   000039   FC           MOV       R4,A
   \   00003A   AE..         MOV       R6,?V0
   \   00003C   EA           MOV       A,R2
   \   00003D   6E           XRL       A,R6
   \   00003E   4B           ORL       A,R3
   \   00003F   70CE         JNZ       ??GetBindingTableEntry_1
   1000                {
   1001                  rtrn = BindingTable+idx;
   \   000041   A882         MOV       R0,DPL
   \   000043   A983         MOV       R1,DPH
   1002                  break;
   1003                }
   1004              }
   1005            }
   1006          #else
   1007            (void)Nth;
   1008          #endif
   1009          
   1010            return rtrn;
   \                     ??GetBindingTableEntry_2:
   \   000045   E8           MOV       A,R0
   \   000046   FA           MOV       R2,A
   \   000047   E9           MOV       A,R1
   \   000048   FB           MOV       R3,A
   \   000049   02....       LJMP      ?Subroutine2 & 0xFFFF
   1011          }
   1012          
   1013          #if !defined ( BINDINGTABLE_NV_SINGLES )
   1014          /*********************************************************************
   1015           * @fn          BindInitNV
   1016           *
   1017           * @brief       Initialize the Binding NV Item
   1018           *
   1019           * @param       none
   1020           *
   1021           * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1022           *              exist in NV, NV_OPER_FAILED if failure.
   1023           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1024          byte BindInitNV( void )
   \                     BindInitNV:
   1025          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1026            byte ret;
   1027          
   1028            // Initialize the device list
   1029            ret = osal_nv_item_init( ZCD_NV_BINDING_TABLE,
   1030                            (uint16)( sizeof( nvBindingHdr_t ) + NV_BIND_ITEM_SIZE ), NULL );
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005   E4           CLR       A
   \   000006   F5..         MOV       ?V0,A
   \   000008   F5..         MOV       ?V1,A
   \   00000A   78..         MOV       R0,#?V0
   \   00000C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00000F   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000012   FC           MOV       R4,A
   \   000013   E4           CLR       A
   \   000014   39           ADDC      A,R1
   \   000015   FD           MOV       R5,A
   \   000016   7A41         MOV       R2,#0x41
   \   000018   7B00         MOV       R3,#0x0
   \   00001A   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00001D   7402         MOV       A,#0x2
   \   00001F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000022   E9           MOV       A,R1
   \   000023   FE           MOV       R6,A
   1031          
   1032            if ( ret != ZSUCCESS )
   \   000024   6003         JZ        ??BindInitNV_0
   1033            {
   1034              BindSetDefaultNV();
   \   000026                ; Setup parameters for call to function BindSetDefaultNV
   \   000026   12....       LCALL     `??BindSetDefaultNV::?relay`; Banked call to: BindSetDefaultNV
   1035            }
   1036          
   1037            return ( ret );
   \                     ??BindInitNV_0:
   \   000029   EE           MOV       A,R6
   \   00002A   F9           MOV       R1,A
   \   00002B   02....       LJMP      ??Subroutine34_0 & 0xFFFF
   1038          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   F8           MOV       R0,A
   \   000006   7401         MOV       A,#0x1
   \   000008   93           MOVC      A,@A+DPTR
   \   000009   F9           MOV       R1,A
   \   00000A   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000D   E4           CLR       A
   \   00000E   93           MOVC      A,@A+DPTR
   \   00000F   F5..         MOV       ?V0,A
   \   000011   E8           MOV       A,R0
   \   000012   85..F0       MOV       B,?V0
   \   000015   A4           MUL       AB
   \   000016   F8           MOV       R0,A
   \   000017   AAF0         MOV       R2,B
   \   000019   85..F0       MOV       B,?V0
   \   00001C   E9           MOV       A,R1
   \   00001D   A4           MUL       AB
   \   00001E   2A           ADD       A,R2
   \   00001F   F9           MOV       R1,A
   \   000020   E8           MOV       A,R0
   \   000021   2402         ADD       A,#0x2
   \   000023   22           RET
   1039          
   1040          /*********************************************************************
   1041           * @fn          BindSetDefaultNV
   1042           *
   1043           * @brief       Write the defaults to NV
   1044           *
   1045           * @param       none
   1046           *
   1047           * @return      none
   1048           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1049          void BindSetDefaultNV( void )
   \                     BindSetDefaultNV:
   1050          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1051            nvBindingHdr_t hdr;
   1052          
   1053            // Initialize the header
   1054            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   1055          
   1056            // Save off the header
   1057            osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof( nvBindingHdr_t ), &hdr );
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   A8..         MOV       R0,?XSP + 0
   \   000016   A9..         MOV       R1,?XSP + 1
   \   000018   88..         MOV       ?V0,R0
   \   00001A   89..         MOV       ?V1,R1
   \   00001C   78..         MOV       R0,#?V0
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV       ?V0,#0x2
   \   000024   75..00       MOV       ?V1,#0x0
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00002F   12....       LCALL     ?DEALLOC_XSTACK8
   1058          }
   \   000032   7402         MOV       A,#0x2
   \   000034   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004                REQUIRE ??Subroutine42_0
   \   000004                ; // Fall through to label ??Subroutine42_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   7A41         MOV       R2,#0x41
   \   000002   7B00         MOV       R3,#0x0
   \   000004   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000007   7404         MOV       A,#0x4
   \   000009   22           RET
   1059          
   1060          #if !defined ( DONT_UPGRADE_BIND )
   1061          /*********************************************************************
   1062           * @fn          BindCopyBackupToNewNV
   1063           *
   1064           * @brief       Creates the New NV item, copies the backup data into
   1065           *              the New NV ID, and Deletes the duplicate NV item.
   1066           *
   1067           * @param       dupLen - NV item length of the old Binding table.
   1068           * @param       newLen - NV item length of the new Binding table to be created.
   1069           *
   1070           * @return      ZSuccess - All the actions were successful.
   1071           *              ZFailure - Any of the actions failed.
   1072           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1073          static uint8 BindCopyBackupToNewNV( uint16 dupLen, uint16 newLen )
   \                     BindCopyBackupToNewNV:
   1074          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   1075            uint8 status = ZSuccess;
   \   000012   75..00       MOV       ?V2,#0x0
   1076            uint16 bindLen;
   1077          
   1078            bindLen = osal_nv_item_len( ZCD_NV_BINDING_TABLE );
   \   000015                ; Setup parameters for call to function osal_nv_item_len
   \   000015   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000018   AC..         MOV       R4,?V4
   \   00001A   AD..         MOV       R5,?V5
   1079          
   1080          
   1081            if ( ( bindLen > 0 ) && ( bindLen != newLen ) )
   \   00001C   EA           MOV       A,R2
   \   00001D   4D           ORL       A,R5
   \   00001E   6011         JZ        ??BindCopyBackupToNewNV_0
   \   000020   E5..         MOV       A,?V0
   \   000022   6C           XRL       A,R4
   \   000023   7003         JNZ       ??BindCopyBackupToNewNV_1
   \   000025   E5..         MOV       A,?V1
   \   000027   6D           XRL       A,R5
   \                     ??BindCopyBackupToNewNV_1:
   \   000028   6007         JZ        ??BindCopyBackupToNewNV_0
   1082            {
   1083              // The existing item does not match the New length
   1084              osal_nv_delete( ZCD_NV_BINDING_TABLE, bindLen );
   \   00002A                ; Setup parameters for call to function osal_nv_delete
   \   00002A   7A41         MOV       R2,#0x41
   \   00002C   7B00         MOV       R3,#0x0
   \   00002E   12....       LCALL     `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   1085            }
   1086          
   1087            // Create Binding Table NV item with the NEW legth
   1088            if ( osal_nv_item_init( ZCD_NV_BINDING_TABLE, newLen, NULL ) != NV_OPER_FAILED )
   \                     ??BindCopyBackupToNewNV_0:
   \   000031                ; Setup parameters for call to function osal_nv_item_init
   \   000031   E4           CLR       A
   \   000032   F5..         MOV       ?V4,A
   \   000034   F5..         MOV       ?V5,A
   \   000036   78..         MOV       R0,#?V4
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   AC..         MOV       R4,?V0
   \   00003D   AD..         MOV       R5,?V1
   \   00003F   7A41         MOV       R2,#0x41
   \   000041   7B00         MOV       R3,#0x0
   \   000043   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000046   7402         MOV       A,#0x2
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
   \   00004B   E9           MOV       A,R1
   \   00004C   640A         XRL       A,#0xa
   \   00004E   7003         JNZ       $+5
   \   000050   02....       LJMP      ??BindCopyBackupToNewNV_2 & 0xFFFF
   1089            {
   1090              nvBindingHdr_t hdrBackup;
   1091          
   1092              // Copy ONLY the valid records from the duplicate NV table into the new table
   1093              // at the end of this process the table content will be compacted
   1094              if ( osal_nv_read( ZCD_NV_DUPLICATE_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdrBackup ) == ZSuccess )
   \   000053                ; Setup parameters for call to function osal_nv_read
   \   000053   7402         MOV       A,#0x2
   \   000055   12....       LCALL     ?XSTACK_DISP100_8
   \   000058   88..         MOV       ?V0,R0
   \   00005A   89..         MOV       ?V1,R1
   \   00005C   78..         MOV       R0,#?V0
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000061   75..02       MOV       ?V0,#0x2
   \   000064   75..00       MOV       ?V1,#0x0
   \   000067   78..         MOV       R0,#?V0
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006C   7C00         MOV       R4,#0x0
   \   00006E   7D00         MOV       R5,#0x0
   \   000070   7A00         MOV       R2,#0x0
   \   000072   7B03         MOV       R3,#0x3
   \   000074   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000077   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007A   E9           MOV       A,R1
   \   00007B   6003         JZ        $+5
   \   00007D   02....       LJMP      ??BindCopyBackupToNewNV_2 & 0xFFFF
   1095              {
   1096                bindTableIndex_t i;
   1097                uint16 validBackupRecs = 0;
   \   000080   85..82       MOV       DPL,?XSP + 0
   \   000083   85..83       MOV       DPH,?XSP + 1
   \   000086   E4           CLR       A
   \   000087   F0           MOVX      @DPTR,A
   \   000088   A3           INC       DPTR
   \   000089   F0           MOVX      @DPTR,A
   1098                BindingEntry_t backupRec;
   1099          
   1100                // Read in the device list. This loop will stop when:
   1101                // The total number of valid records has been reached either because:
   1102                //          The new table is full of valid records OR
   1103                //          The old table has less valid records than the size of the table
   1104                for ( i = 0; ( validBackupRecs < gNWK_MAX_BINDING_ENTRIES ) && ( validBackupRecs < hdrBackup.numRecs ); i++ )
   \   00008A   75..00       MOV       ?V0,#0x0
   \   00008D   8062         SJMP      ??BindCopyBackupToNewNV_3
   1105                {
   1106                  if ( osal_nv_read( ZCD_NV_DUPLICATE_BINDING_TABLE,
   1107                                    (uint16)(sizeof(nvBindingHdr_t) + (i * NV_BIND_REC_SIZE)),
   1108                                    NV_BIND_REC_SIZE, &backupRec ) == ZSuccess )
   \                     ??BindCopyBackupToNewNV_4:
   \   00008F                ; Setup parameters for call to function osal_nv_read
   \   00008F   7404         MOV       A,#0x4
   \   000091   12....       LCALL     ?XSTACK_DISP100_8
   \   000094   88..         MOV       ?V4,R0
   \   000096   89..         MOV       ?V5,R1
   \   000098   78..         MOV       R0,#?V4
   \   00009A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009D   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   0000A0   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   0000A3   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000A6   7A00         MOV       R2,#0x0
   \   0000A8   7B03         MOV       R3,#0x3
   \   0000AA   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000AD   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV       A,R1
   \   0000B1   6003         JZ        $+5
   \   0000B3   02....       LJMP      ??BindCopyBackupToNewNV_2 & 0xFFFF
   1109                  {
   1110                    if ( backupRec.srcEP != NV_BIND_EMPTY )
   \   0000B6   7404         MOV       A,#0x4
   \   0000B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   F4           CPL       A
   \   0000BD   6030         JZ        ??CrossCallReturnLabel_30
   1111                    {
   1112                      // Save the valid record into the NEW NV table.
   1113                      if ( osal_nv_write( ZCD_NV_BINDING_TABLE,
   1114                                          (uint16)((sizeof(nvBindingHdr_t)) + (validBackupRecs * NV_BIND_REC_SIZE)),
   1115                                          NV_BIND_REC_SIZE, &backupRec ) != ZSuccess )
   \   0000BF                ; Setup parameters for call to function osal_nv_write
   \   0000BF   7404         MOV       A,#0x4
   \   0000C1   12....       LCALL     ?XSTACK_DISP100_8
   \   0000C4   88..         MOV       ?V4,R0
   \   0000C6   89..         MOV       ?V5,R1
   \   0000C8   78..         MOV       R0,#?V4
   \   0000CA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000CD   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   0000D0   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   0000D3   7404         MOV       A,#0x4
   \   0000D5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D8   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000DB   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0000DE   FA           MOV       R2,A
   \   0000DF   85..F0       MOV       B,?V4
   \   0000E2   E9           MOV       A,R1
   \   0000E3   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000E6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000E9   E9           MOV       A,R1
   \   0000EA   7072         JNZ       ??BindCopyBackupToNewNV_2
   1116                      {
   1117                         status = ZFailure;
   1118                         break; // Terminate the loop as soon as a problem with NV is detected
   1119                      }
   1120          
   1121                      validBackupRecs++;
   \   0000EC   12....       LCALL     ?Subroutine23 & 0xFFFF
   1122                    }
   1123                  }
   1124                  else
   1125                  {
   1126                     status = ZFailure;
   1127                     break; // Terminate the loop as soon as a problem with NV is detected
   1128                  }
   1129                }
   \                     ??CrossCallReturnLabel_30:
   \   0000EF   05..         INC       ?V0
   \                     ??BindCopyBackupToNewNV_3:
   \   0000F1   85..82       MOV       DPL,?XSP + 0
   \   0000F4   85..83       MOV       DPH,?XSP + 1
   \   0000F7   C082         PUSH      DPL
   \   0000F9   C083         PUSH      DPH
   \   0000FB   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   0000FE   E4           CLR       A
   \   0000FF   93           MOVC      A,@A+DPTR
   \   000100   F8           MOV       R0,A
   \   000101   D083         POP       DPH
   \   000103   D082         POP       DPL
   \   000105   C3           CLR       C
   \   000106   E0           MOVX      A,@DPTR
   \   000107   98           SUBB      A,R0
   \   000108   A3           INC       DPTR
   \   000109   E0           MOVX      A,@DPTR
   \   00010A   9400         SUBB      A,#0x0
   \   00010C   5021         JNC       ??BindCopyBackupToNewNV_5
   \   00010E   85..82       MOV       DPL,?XSP + 0
   \   000111   85..83       MOV       DPH,?XSP + 1
   \   000114   C082         PUSH      DPL
   \   000116   C083         PUSH      DPH
   \   000118   7402         MOV       A,#0x2
   \   00011A   12....       LCALL     ?XSTACK_DISP0_8
   \   00011D   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000120   D083         POP       DPH
   \   000122   D082         POP       DPL
   \   000124   C3           CLR       C
   \   000125   E0           MOVX      A,@DPTR
   \   000126   98           SUBB      A,R0
   \   000127   A3           INC       DPTR
   \   000128   E0           MOVX      A,@DPTR
   \   000129   99           SUBB      A,R1
   \   00012A   5003         JNC       $+5
   \   00012C   02....       LJMP      ??BindCopyBackupToNewNV_4 & 0xFFFF
   1130          
   1131                // Only save the header and delete the duplicate element if the previous
   1132                // process was successful
   1133                if ( status == ZSuccess )
   1134                {
   1135                  // Save off the header
   1136                  if ( osal_nv_write( ZCD_NV_BINDING_TABLE, 0,
   1137                                      sizeof(nvBindingHdr_t), &validBackupRecs ) == ZSuccess )
   \                     ??BindCopyBackupToNewNV_5:
   \   00012F                ; Setup parameters for call to function osal_nv_write
   \   00012F   A8..         MOV       R0,?XSP + 0
   \   000131   A9..         MOV       R1,?XSP + 1
   \   000133   88..         MOV       ?V0,R0
   \   000135   89..         MOV       ?V1,R1
   \   000137   78..         MOV       R0,#?V0
   \   000139   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00013C   75..02       MOV       ?V0,#0x2
   \   00013F   75..00       MOV       ?V1,#0x0
   \   000142   78..         MOV       R0,#?V0
   \   000144   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000147   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00014A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00014D   E9           MOV       A,R1
   \   00014E   700E         JNZ       ??BindCopyBackupToNewNV_2
   1138                  {
   1139                    // Delete the duplicate NV Item, once the data has been stored in the NEW table
   1140                    if ( osal_nv_delete( ZCD_NV_DUPLICATE_BINDING_TABLE, dupLen ) != ZSuccess )
   \   000150                ; Setup parameters for call to function osal_nv_delete
   \   000150   EE           MOV       A,R6
   \   000151   FC           MOV       R4,A
   \   000152   EF           MOV       A,R7
   \   000153   FD           MOV       R5,A
   \   000154   7A00         MOV       R2,#0x0
   \   000156   7B03         MOV       R3,#0x3
   \   000158   12....       LCALL     `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   \   00015B   E9           MOV       A,R1
   \   00015C   6003         JZ        ??BindCopyBackupToNewNV_6
   1141                    {
   1142                      status = ZFailure;
   1143                    }
   1144                  }
   1145                  else
   1146                  {
   1147                    status = ZFailure;
   1148                  }
   1149                }
   1150              }
   1151              else
   1152              {
   1153                status = ZFailure;
   1154              }
   1155            }
   1156            else
   1157            {
   1158              status = ZFailure;
   \                     ??BindCopyBackupToNewNV_2:
   \   00015E   75..01       MOV       ?V2,#0x1
   1159            }
   1160          
   1161            return ( status );
   \                     ??BindCopyBackupToNewNV_6:
   \   000161   A9..         MOV       R1,?V2
   \   000163   7412         MOV       A,#0x12
   \   000165   80..         SJMP      ??Subroutine44_0
   1162          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   7A41         MOV       R2,#0x41
   \   000002   7B00         MOV       R3,#0x0
   \   000004                REQUIRE ??Subroutine43_0
   \   000004                ; // Fall through to label ??Subroutine43_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000003   8A..         MOV       ?V4,R2
   \   000005   8B..         MOV       ?V5,R3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine45_0
   \   000003                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine48_0:
   \   000000   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000003   7404         MOV       A,#0x4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   A8..         MOV       R0,?V0
   \   000002   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000005   F9           MOV       R1,A
   \   000006   E8           MOV       A,R0
   \   000007   2402         ADD       A,#0x2
   \   000009   FC           MOV       R4,A
   \   00000A   E4           CLR       A
   \   00000B   39           ADDC      A,R1
   \   00000C   FD           MOV       R5,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   F5..         MOV       ?V4,A
   \   000007   7401         MOV       A,#0x1
   \   000009   93           MOVC      A,@A+DPTR
   \   00000A   F5..         MOV       ?V5,A
   \   00000C   E8           MOV       A,R0
   \   00000D   85..F0       MOV       B,?V4
   \   000010   A4           MUL       AB
   \   000011   C8           XCH       A,R0
   \   000012   AAF0         MOV       R2,B
   \   000014   85..F0       MOV       B,?V5
   \   000017   A4           MUL       AB
   \   000018   2A           ADD       A,R2
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   2401         ADD       A,#0x1
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   A3           INC       DPTR
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   3400         ADDC      A,#0x0
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   A4           MUL       AB
   \   000001   2A           ADD       A,R2
   \   000002   F9           MOV       R1,A
   \   000003   E8           MOV       A,R0
   \   000004   2402         ADD       A,#0x2
   \   000006   FC           MOV       R4,A
   \   000007   E4           CLR       A
   \   000008   39           ADDC      A,R1
   \   000009   FD           MOV       R5,A
   \   00000A   12....       LCALL     ??Subroutine42_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00000D   22           RET
   1163          #endif // !DONT_UPGRADE_BIND
   1164          
   1165          #if !defined ( DONT_UPGRADE_BIND )
   1166          /*********************************************************************
   1167           * @fn          BindUpgradeTableInNV
   1168           *
   1169           * @brief       Verifies if the existing table in NV has different size
   1170           *              than the table defined by parameters in the current code.
   1171           *              If different, creates a backup table, deletes the existing
   1172           *              table and creates the new table with the new size. After
   1173           *              this process is done ZCD_NV_BINDING_TABLE NV item contains
   1174           *              only valid records retrieved from the original table, up to
   1175           *              the maximum number of records defined by gNWK_MAX_BINDING_ENTRIES
   1176           *
   1177           * @param       none
   1178           *
   1179           * @return      ZSuccess - the Update process was sucessful.
   1180           *              ZFailure - otherwise.
   1181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine44_0
   \   000002                ; // Fall through to label ??Subroutine44_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1182          static uint8 BindUpgradeTableInNV( void )
   \                     BindUpgradeTableInNV:
   1183          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1184            uint8 status = ZSuccess;
   \   00000A   75..00       MOV       ?V2,#0x0
   1185            nvBindingHdr_t hdr;
   1186            uint16 dupLen;
   1187            uint16 bindLen;
   1188            uint16 newLen;
   1189            bool duplicateReady = FALSE;
   1190          
   1191            // Size of the Binding table based on current paramenters in the code
   1192            newLen = sizeof(nvBindingHdr_t) + NV_BIND_ITEM_SIZE;
   \   00000D   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000010   F5..         MOV       ?V0,A
   \   000012   E4           CLR       A
   \   000013   39           ADDC      A,R1
   \   000014   F5..         MOV       ?V1,A
   1193          
   1194            // Size of the Binding table NV item, this is the whole size of the item,
   1195            // it could inculde invalid records also
   1196            bindLen = osal_nv_item_len( ZCD_NV_BINDING_TABLE );
   \   000016                ; Setup parameters for call to function osal_nv_item_len
   \   000016   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000019   AE..         MOV       R6,?V4
   \   00001B   AF..         MOV       R7,?V5
   1197          
   1198            // Get the number of valid records from the Binding table
   1199            osal_nv_read( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr );
   \   00001D                ; Setup parameters for call to function osal_nv_read
   \   00001D   A8..         MOV       R0,?XSP + 0
   \   00001F   A9..         MOV       R1,?XSP + 1
   \   000021   88..         MOV       ?V4,R0
   \   000023   89..         MOV       ?V5,R1
   \   000025   78..         MOV       R0,#?V4
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   75..02       MOV       ?V4,#0x2
   \   00002D   75..00       MOV       ?V5,#0x0
   \   000030   78..         MOV       R0,#?V4
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000038   12....       LCALL     ?DEALLOC_XSTACK8
   1200          
   1201            // Identify if there is a duplicate NV item, if it is there, that means an
   1202            // Upgrade process did not finish properly last time
   1203            // The length function will return 0 if the Backup NV ID does not exist.
   1204            dupLen = osal_nv_item_len( ZCD_NV_DUPLICATE_BINDING_TABLE );
   \   00003B                ; Setup parameters for call to function osal_nv_item_len
   \   00003B   7A00         MOV       R2,#0x0
   \   00003D   7B03         MOV       R3,#0x3
   \   00003F   12....       LCALL     ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000042   A9..         MOV       R1,?V5
   1205          
   1206            // A duplicate of the original Binding item will be done if:
   1207            // 1) A duplicate NV item DOES NOT exist AND the size of the original Binding
   1208            //    item in NV is different (larger/smaller) than the the length calculated
   1209            //    from the parameters in the code. If they are the same there is no need
   1210            //    to do the Upgrade process.
   1211            // 2) A duplicate NV item exists (probably because the previous upgrade
   1212            //    process was interrupted) and [the original Binding NV items exists AND
   1213            //    has valid recods (it is important to make sure that valid records exist
   1214            //    in the binding table because it is possible that the item was created
   1215            //    but the data was not copied in the previous upgrade process).
   1216            if ( ( ( dupLen == 0 ) && ( bindLen != newLen ) ) ||
   1217                 ( ( dupLen > 0 ) && ( bindLen > 0 ) && ( hdr.numRecs > 0 ) ) )
   \   000044   EA           MOV       A,R2
   \   000045   49           ORL       A,R1
   \   000046   700C         JNZ       ??BindUpgradeTableInNV_0
   \   000048   E5..         MOV       A,?V0
   \   00004A   6E           XRL       A,R6
   \   00004B   7003         JNZ       ??BindUpgradeTableInNV_1
   \   00004D   E5..         MOV       A,?V1
   \   00004F   6F           XRL       A,R7
   \                     ??BindUpgradeTableInNV_1:
   \   000050   700D         JNZ       ??BindUpgradeTableInNV_2
   \   000052   8041         SJMP      ??BindUpgradeTableInNV_3
   \                     ??BindUpgradeTableInNV_0:
   \   000054   EE           MOV       A,R6
   \   000055   4F           ORL       A,R7
   \   000056   602B         JZ        ??BindUpgradeTableInNV_4
   \   000058   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00005B   EA           MOV       A,R2
   \   00005C   4B           ORL       A,R3
   \   00005D   6024         JZ        ??BindUpgradeTableInNV_4
   1218            {
   1219              // Create a copy from original NV item into a duplicate NV item
   1220              if ( ( status = nwkCreateDuplicateNV( ZCD_NV_BINDING_TABLE,
   1221                                                    ZCD_NV_DUPLICATE_BINDING_TABLE ) ) == ZSuccess )
   \                     ??BindUpgradeTableInNV_2:
   \   00005F                ; Setup parameters for call to function nwkCreateDuplicateNV
   \   00005F   7C00         MOV       R4,#0x0
   \   000061   7D03         MOV       R5,#0x3
   \   000063   7A41         MOV       R2,#0x41
   \   000065   7B00         MOV       R3,#0x0
   \   000067   12....       LCALL     `??nwkCreateDuplicateNV::?relay`; Banked call to: nwkCreateDuplicateNV
   \   00006A   E9           MOV       A,R1
   \   00006B   F8           MOV       R0,A
   \   00006C   F5..         MOV       ?V2,A
   \   00006E   7025         JNZ       ??BindUpgradeTableInNV_3
   1222              {
   1223                // Delete the original NV item once the duplicate is ready
   1224                if ( osal_nv_delete( ZCD_NV_BINDING_TABLE, bindLen ) != ZSuccess )
   \   000070                ; Setup parameters for call to function osal_nv_delete
   \   000070   EE           MOV       A,R6
   \   000071   FC           MOV       R4,A
   \   000072   EF           MOV       A,R7
   \   000073   FD           MOV       R5,A
   \   000074   7A41         MOV       R2,#0x41
   \   000076   7B00         MOV       R3,#0x0
   \   000078   12....       LCALL     `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   \   00007B   E9           MOV       A,R1
   \   00007C   6009         JZ        ??BindUpgradeTableInNV_5
   1225                {
   1226                  status = ZFailure;
   \   00007E   75..01       MOV       ?V2,#0x1
   \   000081   8012         SJMP      ??BindUpgradeTableInNV_3
   1227                }
   1228                else
   1229                {
   1230                  duplicateReady = TRUE;
   1231                }
   1232              }
   1233            }
   1234            else if ( ( ( dupLen > 0 ) && ( bindLen == 0 ) ) ||
   1235                      ( ( dupLen > 0 ) && ( bindLen > 0 ) && ( hdr.numRecs == 0 ) ) )
   1236            {
   1237              // If for some reason a duplicate NV item was left in the system from a
   1238              // previous upgrade process and:
   1239              // 1) The original Binding NV item DOES NOT exist OR
   1240              // 2) The original Binding NV item exist, but has no valid records.
   1241              // it is necessary to rely in the data in the Duplicate item to create
   1242              // the Binding table
   1243              bindLen = dupLen;
   \                     ??BindUpgradeTableInNV_4:
   \   000083   AE..         MOV       R6,?V4
   \   000085   E9           MOV       A,R1
   \   000086   FF           MOV       R7,A
   1244          
   1245              duplicateReady = TRUE;
   1246            }
   1247          
   1248            if ( duplicateReady == TRUE )
   1249            {
   1250              // Creates the New Binding table, Copy data from backup and Delete backup NV ID
   1251              status = BindCopyBackupToNewNV( bindLen, newLen );
   \                     ??BindUpgradeTableInNV_5:
   \   000087                ; Setup parameters for call to function BindCopyBackupToNewNV
   \   000087   AC..         MOV       R4,?V0
   \   000089   AD..         MOV       R5,?V1
   \   00008B   EE           MOV       A,R6
   \   00008C   FA           MOV       R2,A
   \   00008D   EF           MOV       A,R7
   \   00008E   FB           MOV       R3,A
   \   00008F   12....       LCALL     `??BindCopyBackupToNewNV::?relay`; Banked call to: BindCopyBackupToNewNV
   \   000092   E9           MOV       A,R1
   \   000093   F5..         MOV       ?V2,A
   1252            }
   1253            return ( status );
   \                     ??BindUpgradeTableInNV_3:
   \   000095   A9..         MOV       R1,?V2
   \   000097   02....       LJMP      ?Subroutine5 & 0xFFFF
   1254          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine46_0
   \   000006                ; // Fall through to label ??Subroutine46_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004                REQUIRE ??Subroutine47_0
   \   000004                ; // Fall through to label ??Subroutine47_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine47_0:
   \   000000   7A41         MOV       R2,#0x41
   \   000002   7B00         MOV       R3,#0x0
   \   000004                REQUIRE ??Subroutine48_0
   \   000004                ; // Fall through to label ??Subroutine48_0
   1255          #endif // !DONT_UPGRADE_BIND
   1256          
   1257          /*********************************************************************
   1258           * @fn          BindRestoreFromNV
   1259           *
   1260           * @brief       Restore the binding table from NV
   1261           *
   1262           * @param       none
   1263           *
   1264           * @return      Number of entries restored
   1265           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1266          uint16 BindRestoreFromNV( void )
   \                     BindRestoreFromNV:
   1267          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1268            nvBindingHdr_t hdr;
   1269          
   1270            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   1271          
   1272          #if !defined ( DONT_UPGRADE_BIND )
   1273            if ( BindUpgradeTableInNV() == ZSuccess )
   \   000014                ; Setup parameters for call to function BindUpgradeTableInNV
   \   000014   12....       LCALL     `??BindUpgradeTableInNV::?relay`; Banked call to: BindUpgradeTableInNV
   \   000017   E9           MOV       A,R1
   \   000018   6003         JZ        $+5
   \   00001A   02....       LJMP      ??BindRestoreFromNV_0 & 0xFFFF
   1274          #endif
   1275            {
   1276              if ( osal_nv_read( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr ) == ZSuccess )
   \   00001D                ; Setup parameters for call to function osal_nv_read
   \   00001D   A8..         MOV       R0,?XSP + 0
   \   00001F   A9..         MOV       R1,?XSP + 1
   \   000021   88..         MOV       ?V0,R0
   \   000023   89..         MOV       ?V1,R1
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   75..02       MOV       ?V0,#0x2
   \   00002D   75..00       MOV       ?V1,#0x0
   \   000030   78..         MOV       R0,#?V0
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000038   12....       LCALL     ?DEALLOC_XSTACK8
   \   00003B   E9           MOV       A,R1
   \   00003C   7060         JNZ       ??BindRestoreFromNV_0
   1277              {
   1278                bindTableIndex_t x;
   1279                uint16 validRecsCount = 0;
   \   00003E   7E00         MOV       R6,#0x0
   \   000040   7F00         MOV       R7,#0x0
   1280          
   1281                // Read in the device list
   1282                for ( x = 0; ( x < gNWK_MAX_BINDING_ENTRIES ) && ( validRecsCount < hdr.numRecs ); x++ )
   \   000042   75..00       MOV       ?V0,#0x0
   \   000045   803B         SJMP      ??BindRestoreFromNV_1
   1283                {
   1284                  if ( osal_nv_read( ZCD_NV_BINDING_TABLE,
   1285                                     (uint16)(sizeof(nvBindingHdr_t) + (x * NV_BIND_REC_SIZE)),
   1286                                     NV_BIND_REC_SIZE, &BindingTable[x] ) == ZSUCCESS )
   \                     ??BindRestoreFromNV_2:
   \   000047   E5..         MOV       A,?V0
   \   000049   75F00E       MOV       B,#0xe
   \   00004C   A4           MUL       AB
   \   00004D   F8           MOV       R0,A
   \   00004E   A9F0         MOV       R1,B
   \   000050   74..         MOV       A,#BindingTable & 0xff
   \   000052   28           ADD       A,R0
   \   000053   F5..         MOV       ?V2,A
   \   000055   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000057   39           ADDC      A,R1
   \   000058   F5..         MOV       ?V3,A
   \   00005A                ; Setup parameters for call to function osal_nv_read
   \   00005A   78..         MOV       R0,#?V2
   \   00005C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005F   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000062   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   000065   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000068   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00006B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006E   E9           MOV       A,R1
   \   00006F   700F         JNZ       ??BindRestoreFromNV_3
   1287                  {
   1288                    if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \   000071   85..82       MOV       DPL,?V2
   \   000074   85..83       MOV       DPH,?V3
   \   000077   E0           MOVX      A,@DPTR
   \   000078   F4           CPL       A
   \   000079   6005         JZ        ??BindRestoreFromNV_3
   1289                    {
   1290                      validRecsCount++;
   \   00007B   0E           INC       R6
   \   00007C   EE           MOV       A,R6
   \   00007D   7001         JNZ       ??BindRestoreFromNV_3
   \   00007F   0F           INC       R7
   1291                    }
   1292                  }
   1293                }
   \                     ??BindRestoreFromNV_3:
   \   000080   05..         INC       ?V0
   \                     ??BindRestoreFromNV_1:
   \   000082   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000085   E4           CLR       A
   \   000086   93           MOVC      A,@A+DPTR
   \   000087   F8           MOV       R0,A
   \   000088   E5..         MOV       A,?V0
   \   00008A   C3           CLR       C
   \   00008B   98           SUBB      A,R0
   \   00008C   5010         JNC       ??BindRestoreFromNV_0
   \   00008E   85..82       MOV       DPL,?XSP + 0
   \   000091   85..83       MOV       DPH,?XSP + 1
   \   000094   12....       LCALL     ?Subroutine20 & 0xFFFF
   1294              }
   1295            }
   \                     ??CrossCallReturnLabel_27:
   \   000097   C3           CLR       C
   \   000098   EE           MOV       A,R6
   \   000099   98           SUBB      A,R0
   \   00009A   EF           MOV       A,R7
   \   00009B   99           SUBB      A,R1
   \   00009C   40A9         JC        ??BindRestoreFromNV_2
   1296            return ( hdr.numRecs );
   \                     ??BindRestoreFromNV_0:
   \   00009E   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0000A1   02....       LJMP      ?Subroutine5 & 0xFFFF
   1297          }
   1298          
   1299          /*********************************************************************
   1300           * @fn          BindWriteNV
   1301           *
   1302           * @brief       Save the Binding Table in NV
   1303           *
   1304           * @param       none
   1305           *
   1306           * @return      none
   1307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1308          void BindWriteNV( void )
   \                     BindWriteNV:
   1309          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV       A,#-0x10
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1310            BindingEntry_t *pBind;
   1311            BindingEntry_t bind;
   1312            nvBindingHdr_t hdr;
   1313            bindTableIndex_t x;
   1314          
   1315            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   1316          
   1317            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000014   7E00         MOV       R6,#0x0
   \   000016   8070         SJMP      ??BindWriteNV_0
   1318            {
   1319              pBind = &BindingTable[x];
   \                     ??BindWriteNV_1:
   \   000018   EE           MOV       A,R6
   \   000019   75F00E       MOV       B,#0xe
   \   00001C   A4           MUL       AB
   \   00001D   F8           MOV       R0,A
   \   00001E   A9F0         MOV       R1,B
   \   000020   74..         MOV       A,#BindingTable & 0xff
   \   000022   28           ADD       A,R0
   \   000023   F5..         MOV       ?V0,A
   \   000025   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000027   39           ADDC      A,R1
   \   000028   F5..         MOV       ?V1,A
   1320          
   1321              osal_memcpy( &bind, pBind, gBIND_REC_SIZE );
   \   00002A                ; Setup parameters for call to function osal_memcpy
   \   00002A   85....       MOV       ?V4,?V0
   \   00002D   F5..         MOV       ?V5,A
   \   00002F   75..00       MOV       ?V6,#0x0
   \   000032   78..         MOV       R0,#?V4
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000037   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00003A   7405         MOV       A,#0x5
   \   00003C   12....       LCALL     ?XSTACK_DISP101_8
   \   00003F   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000042   7403         MOV       A,#0x3
   \   000044   12....       LCALL     ?DEALLOC_XSTACK8
   1322          
   1323              // Save the record to NV
   1324              osal_nv_write( ZCD_NV_BINDING_TABLE,
   1325                             (uint16)((sizeof(nvBindingHdr_t)) + (x * NV_BIND_REC_SIZE)),
   1326                             NV_BIND_REC_SIZE, &bind );
   \   000047                ; Setup parameters for call to function osal_nv_write
   \   000047   7402         MOV       A,#0x2
   \   000049   12....       LCALL     ?XSTACK_DISP100_8
   \   00004C   88..         MOV       ?V2,R0
   \   00004E   89..         MOV       ?V3,R1
   \   000050   78..         MOV       R0,#?V2
   \   000052   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000055   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000058   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   00005B   EE           MOV       A,R6
   \   00005C   F8           MOV       R0,A
   \   00005D   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000060   E4           CLR       A
   \   000061   93           MOVC      A,@A+DPTR
   \   000062   F5..         MOV       ?V2,A
   \   000064   7401         MOV       A,#0x1
   \   000066   93           MOVC      A,@A+DPTR
   \   000067   F5..         MOV       ?V3,A
   \   000069   E8           MOV       A,R0
   \   00006A   85..F0       MOV       B,?V2
   \   00006D   A4           MUL       AB
   \   00006E   C8           XCH       A,R0
   \   00006F   AAF0         MOV       R2,B
   \   000071   85..F0       MOV       B,?V3
   \   000074   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000077   12....       LCALL     ?DEALLOC_XSTACK8
   1327          
   1328              if ( pBind->srcEP != NV_BIND_EMPTY )
   \   00007A   85..82       MOV       DPL,?V0
   \   00007D   85..83       MOV       DPH,?V1
   \   000080   E0           MOVX      A,@DPTR
   \   000081   F4           CPL       A
   \   000082   6003         JZ        ??CrossCallReturnLabel_31
   1329              {
   1330                hdr.numRecs++;
   \   000084   12....       LCALL     ?Subroutine23 & 0xFFFF
   1331              }
   1332            }
   \                     ??CrossCallReturnLabel_31:
   \   000087   0E           INC       R6
   \                     ??BindWriteNV_0:
   \   000088   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00008B   E4           CLR       A
   \   00008C   93           MOVC      A,@A+DPTR
   \   00008D   F8           MOV       R0,A
   \   00008E   EE           MOV       A,R6
   \   00008F   C3           CLR       C
   \   000090   98           SUBB      A,R0
   \   000091   4085         JC        ??BindWriteNV_1
   1333          
   1334            // Save off the header
   1335            osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr );
   \   000093                ; Setup parameters for call to function osal_nv_write
   \   000093   A8..         MOV       R0,?XSP + 0
   \   000095   A9..         MOV       R1,?XSP + 1
   \   000097   88..         MOV       ?V0,R0
   \   000099   89..         MOV       ?V1,R1
   \   00009B   78..         MOV       R0,#?V0
   \   00009D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A0   75..02       MOV       ?V0,#0x2
   \   0000A3   75..00       MOV       ?V1,#0x0
   \   0000A6   78..         MOV       R0,#?V0
   \   0000A8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AB   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0000AE   12....       LCALL     ?DEALLOC_XSTACK8
   1336          }
   \   0000B1   7410         MOV       A,#0x10
   \   0000B3   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B6   7F07         MOV       R7,#0x7
   \   0000B8   02....       LJMP      ?BANKED_LEAVE_XDATA
   1337          
   1338          #else // !BINDINGTABLE_NV_SINGLES
   1339          /*********************************************************************
   1340           * @fn          BindInitNV
   1341           *
   1342           * @brief       Initialize the Binding NV Item
   1343           *
   1344           * @param       none
   1345           *
   1346           * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1347           *              exist in NV, NV_OPER_FAILED if failure.
   1348           */
   1349          byte BindInitNV( void )
   1350          {
   1351            bindTableIndex_t x;
   1352          
   1353            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1354            {
   1355              // Initialize each binding record
   1356              osal_nv_item_init_ex( ZCD_NV_EX_BINDING_TABLE, x, NV_BIND_REC_SIZE, NULL );
   1357            }
   1358            return ( ZSUCCESS );
   1359          }
   1360          
   1361          /*********************************************************************
   1362           * @fn          BindSetDefaultNV
   1363           *
   1364           * @brief       Write the defaults to NV
   1365           *
   1366           * @param       none
   1367           *
   1368           * @return      none
   1369           */
   1370          void BindSetDefaultNV( void )
   1371          {
   1372            BindingEntry_t bind;
   1373            bindTableIndex_t x;
   1374          
   1375            // Initialize a binding record
   1376            osal_memset( &bind, 0xFF, sizeof ( BindingEntry_t ) );
   1377          
   1378            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1379            {
   1380              // Over write each binding record with an "empty" record
   1381              osal_nv_write_ex( ZCD_NV_EX_BINDING_TABLE, x, 0, NV_BIND_REC_SIZE, &bind );
   1382            }
   1383          }
   1384          
   1385          /*********************************************************************
   1386           * @fn          BindRestoreFromNV
   1387           *
   1388           * @brief       Restore the binding table from NV
   1389           *
   1390           * @param       none
   1391           *
   1392           * @return      Number of entries restored (non-emtpy)
   1393           */
   1394          uint16 BindRestoreFromNV( void )
   1395          {
   1396            bindTableIndex_t x;
   1397            uint16 validRecsCount = 0;
   1398          
   1399            // Read in the device list
   1400            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1401            {
   1402              if ( osal_nv_read_ex( ZCD_NV_EX_BINDING_TABLE, x, 0,
   1403                               (uint16)NV_BIND_REC_SIZE, &BindingTable[x] ) == ZSUCCESS )
   1404              {
   1405                // Check for non-empty record
   1406                if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   1407                {
   1408                  // Count non-empty records
   1409                  validRecsCount++;
   1410                }
   1411              }
   1412            }
   1413            return ( validRecsCount );
   1414          }
   1415          
   1416          /*********************************************************************
   1417           * @fn          BindWriteNV
   1418           *
   1419           * @brief       Copy the Binding Table in NV
   1420           *
   1421           * @param       none
   1422           *
   1423           * @return      none
   1424           */
   1425          void BindWriteNV( void )
   1426          {
   1427            bindTableIndex_t x;
   1428          
   1429            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1430            {
   1431              // Save the record to NV
   1432              osal_nv_write_ex( ZCD_NV_EX_BINDING_TABLE, x, 0,
   1433                               (uint16)NV_BIND_REC_SIZE, &BindingTable[x] );
   1434            }
   1435          }
   1436          #endif // BINDINGTABLE_NV_SINGLES
   1437          
   1438          /*********************************************************************
   1439          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     52   BindCopyBackupToNewNV
        0     32   -> osal_nv_delete
        0     34   -> osal_nv_item_init
        0     32   -> osal_nv_item_len
        0     36   -> osal_nv_read
        0     36   -> osal_nv_write
      0     12   BindInitNV
        0     10   -> BindSetDefaultNV
        0     12   -> osal_nv_item_init
      0     20   BindRestoreFromNV
        0     16   -> BindUpgradeTableInNV
        0     20   -> osal_nv_read
      0     26   BindSetDefaultNV
        0     16   -> osal_nv_write
      0     36   BindUpgradeTableInNV
        0     16   -> BindCopyBackupToNewNV
        0     16   -> nwkCreateDuplicateNV
        0     16   -> osal_nv_delete
        0     16   -> osal_nv_item_len
        0     20   -> osal_nv_read
      0     35   BindWriteNV
        0     34   -> osal_memcpy
        0     35   -> osal_nv_write
      0      9   GetBindingTableEntry
      0     10   InitBindingTable
        0     10   -> osal_memset
      0     29   bindAddClusterIdToList
      1     25   bindAddEntry
        0     20   -> bindAddClusterIdToList
        0     20   -> bindAddrIndexGet
        0     20   -> bindAddrMgrLocalLoad
        0     20   -> bindFindEmpty
        0     20   -> bindIsClusterIDinList
        0     23   -> osal_memcpy
      2     33   bindAddrIndexGet
        2     13   -> AddrMgrEntryLookupExt
        2     13   -> AddrMgrEntryLookupNwk
        2     13   -> AddrMgrEntryUpdate
        2     13   -> AddrMgrExtAddrSet
      0     43   bindAddrMgrLocalLoad
        0     23   -> AddrMgrEntryUpdate
        0     23   -> AddrMgrExtAddrSet
        0     23   -> NLME_GetCoordExtAddr
        0     23   -> NLME_GetCoordShortAddr
        0     23   -> NLME_GetExtAddr
      2     25   bindAddressClear
        2     13   -> AddrMgrEntryRelease
      0      9   bindCapacity
      0     14   bindFind
        0     14   -> bindIsClusterIDinList
      2     20   bindFindEmpty
      0     13   bindFindExisting
        0     13   -> bindingAddrMgsHelperFind
      0     29   bindIsClusterIDinList
      0     14   bindNumBoundTo
        0     14   -> bindingAddrMgsHelperFind
      2      0   bindNumOfEntries
      0     12   bindNumReflections
        0     12   -> bindIsClusterIDinList
      0     13   bindRemoveClusterIdFromList
      0     12   bindRemoveDev
        0     12   -> bindAddressClear
        0     12   -> bindRemoveEntry
        0     12   -> bindingAddrMgsHelperFind
      2     12   bindRemoveEntry
        2      0   -> osal_memset
      0     10   bindRemoveSrcDev
        0     10   -> bindAddressClear
        0     10   -> bindRemoveEntry
      0     21   bindUpdateAddr
        0     21   -> bindingAddrMgsHelperFind
      0     22   bindingAddrMgsHelperConvert
        0     22   -> AddrMgrEntryGet
        0     22   -> sAddrExtCpy
      2     13   bindingAddrMgsHelperConvertShort
        2     13   -> AddrMgrEntryGet
      2     34   bindingAddrMgsHelperFind
        2     13   -> AddrMgrEntryLookupExt
        2     13   -> AddrMgrEntryLookupNwk
        2     13   -> AddrMgrExtAddrSet


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine34_0
       5  ??Subroutine35_0
      16  ??Subroutine36_0
       6  ??Subroutine37_0
       6  ??Subroutine38_0
       5  ??Subroutine39_0
       7  ??Subroutine40_0
       8  ??Subroutine41_0
      10  ??Subroutine42_0
       8  ??Subroutine43_0
       3  ??Subroutine44_0
       5  ??Subroutine45_0
       6  ??Subroutine46_0
       4  ??Subroutine47_0
       6  ??Subroutine48_0
       3  ?Subroutine0
       2  ?Subroutine1
      22  ?Subroutine10
      11  ?Subroutine11
      11  ?Subroutine12
       1  ?Subroutine13
      17  ?Subroutine14
       7  ?Subroutine15
      11  ?Subroutine16
       7  ?Subroutine17
      14  ?Subroutine18
       4  ?Subroutine19
       5  ?Subroutine2
       6  ?Subroutine20
      10  ?Subroutine21
       6  ?Subroutine22
      16  ?Subroutine23
       9  ?Subroutine24
      15  ?Subroutine25
       4  ?Subroutine26
       4  ?Subroutine27
      26  ?Subroutine28
      12  ?Subroutine29
       5  ?Subroutine3
      10  ?Subroutine30
       4  ?Subroutine31
      14  ?Subroutine32
       4  ?Subroutine33
       5  ?Subroutine4
       2  ?Subroutine5
      36  ?Subroutine6
      14  ?Subroutine7
       7  ?Subroutine8
      21  ?Subroutine9
     359  BindCopyBackupToNewNV
      46  BindInitNV
     164  BindRestoreFromNV
      55  BindSetDefaultNV
     154  BindUpgradeTableInNV
     187  BindWriteNV
      76  GetBindingTableEntry
     116  InitBindingTable
      71  bindAddClusterIdToList
     334  bindAddEntry
      98  bindAddrIndexGet
     144  bindAddrMgrLocalLoad
       1  bindAddrMgrLocalLoaded
      95  bindAddressClear
      62  bindCapacity
      80  bindFind
      39  bindFindEmpty
     144  bindFindExisting
      69  bindIsClusterIDinList
     135  bindNumBoundTo
      46  bindNumOfEntries
      69  bindNumReflections
     128  bindRemoveClusterIdFromList
     138  bindRemoveDev
      17  bindRemoveEntry
      82  bindRemoveSrcDev
     114  bindUpdateAddr
      75  bindingAddrMgsHelperConvert
      31  bindingAddrMgsHelperConvertShort
      42  bindingAddrMgsHelperFind
       2  pBindInitNV
       2  pBindRestoreFromNV
       2  pBindSetDefaultNV
       2  pBindWriteNV
       2  pbindAddEntry
       2  pbindNumOfEntries
       2  pbindRemoveDev
     174  -- Other

 
 3 615 bytes in segment BANKED_CODE
   174 bytes in segment BANK_RELAYS
    15 bytes in segment XDATA_Z
 
   174 bytes of CODE     memory
 3 615 bytes of HUGECODE memory
    15 bytes of XDATA    memory

Errors: none
Warnings: none
